// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GSNET_GAMEEVENT_H_
#define FLATBUFFERS_GENERATED_GSNET_GAMEEVENT_H_

#include "flatbuffers/flatbuffers.h"

namespace GameEvent {

struct CLConnection;

struct SVConnectionStatus;

struct SVPlayerConnected;

struct SVGenerateMap;

struct CLMapGenerated;

struct SVGameStart;

struct CLActionMove;

struct SVActionMove;

struct CLActionItem;

struct SVActionItem;

struct CLActionSwamp;

struct SVActionSwamp;

struct CLActionDuel;

struct SVActionDuel;

struct SVSpawnPlayer;

struct SVRespawnPlayer;

struct SVSpawnItem;

struct SVSpawnConstr;

struct SVGameEnd;

struct Event;

enum ConnectionStatus {
  ConnectionStatus_ACCEPTED = 0,
  ConnectionStatus_REFUSED = 1,
  ConnectionStatus_MIN = ConnectionStatus_ACCEPTED,
  ConnectionStatus_MAX = ConnectionStatus_REFUSED
};

inline const char **EnumNamesConnectionStatus() {
  static const char *names[] = {
    "ACCEPTED",
    "REFUSED",
    nullptr
  };
  return names;
}

inline const char *EnumNameConnectionStatus(ConnectionStatus e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesConnectionStatus()[index];
}

enum ActionItemType {
  ActionItemType_TAKE = 0,
  ActionItemType_DROP = 1,
  ActionItemType_USE = 2,
  ActionItemType_MIN = ActionItemType_TAKE,
  ActionItemType_MAX = ActionItemType_USE
};

inline const char **EnumNamesActionItemType() {
  static const char *names[] = {
    "TAKE",
    "DROP",
    "USE",
    nullptr
  };
  return names;
}

inline const char *EnumNameActionItemType(ActionItemType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesActionItemType()[index];
}

enum ActionSwampStatus {
  ActionSwampStatus_STARTED = 0,
  ActionSwampStatus_ESCAPED = 1,
  ActionSwampStatus_DIED = 2,
  ActionSwampStatus_MIN = ActionSwampStatus_STARTED,
  ActionSwampStatus_MAX = ActionSwampStatus_DIED
};

inline const char **EnumNamesActionSwampStatus() {
  static const char *names[] = {
    "STARTED",
    "ESCAPED",
    "DIED",
    nullptr
  };
  return names;
}

inline const char *EnumNameActionSwampStatus(ActionSwampStatus e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesActionSwampStatus()[index];
}

enum ActionDuelType {
  ActionDuelType_STARTED = 0,
  ActionDuelType_ATTACK = 1,
  ActionDuelType_ESCAPE = 2,
  ActionDuelType_KILL = 3,
  ActionDuelType_MIN = ActionDuelType_STARTED,
  ActionDuelType_MAX = ActionDuelType_KILL
};

inline const char **EnumNamesActionDuelType() {
  static const char *names[] = {
    "STARTED",
    "ATTACK",
    "ESCAPE",
    "KILL",
    nullptr
  };
  return names;
}

inline const char *EnumNameActionDuelType(ActionDuelType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesActionDuelType()[index];
}

enum ItemType {
  ItemType_KEY = 0,
  ItemType_SWORD = 1,
  ItemType_MIN = ItemType_KEY,
  ItemType_MAX = ItemType_SWORD
};

inline const char **EnumNamesItemType() {
  static const char *names[] = {
    "KEY",
    "SWORD",
    nullptr
  };
  return names;
}

inline const char *EnumNameItemType(ItemType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesItemType()[index];
}

enum ConstrType {
  ConstrType_DOOR = 0,
  ConstrType_GRAVEYARD = 1,
  ConstrType_SWAMP = 2,
  ConstrType_MIN = ConstrType_DOOR,
  ConstrType_MAX = ConstrType_SWAMP
};

inline const char **EnumNamesConstrType() {
  static const char *names[] = {
    "DOOR",
    "GRAVEYARD",
    "SWAMP",
    nullptr
  };
  return names;
}

inline const char *EnumNameConstrType(ConstrType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesConstrType()[index];
}

enum Events {
  Events_NONE = 0,
  Events_CLConnection = 1,
  Events_SVConnectionStatus = 2,
  Events_SVPlayerConnected = 3,
  Events_SVGenerateMap = 4,
  Events_CLMapGenerated = 5,
  Events_SVGameStart = 6,
  Events_CLActionMove = 7,
  Events_SVActionMove = 8,
  Events_CLActionItem = 9,
  Events_SVActionItem = 10,
  Events_CLActionSwamp = 11,
  Events_SVActionSwamp = 12,
  Events_CLActionDuel = 13,
  Events_SVActionDuel = 14,
  Events_SVSpawnPlayer = 15,
  Events_SVRespawnPlayer = 16,
  Events_SVSpawnItem = 17,
  Events_SVSpawnConstr = 18,
  Events_SVGameEnd = 19,
  Events_MIN = Events_NONE,
  Events_MAX = Events_SVGameEnd
};

inline const char **EnumNamesEvents() {
  static const char *names[] = {
    "NONE",
    "CLConnection",
    "SVConnectionStatus",
    "SVPlayerConnected",
    "SVGenerateMap",
    "CLMapGenerated",
    "SVGameStart",
    "CLActionMove",
    "SVActionMove",
    "CLActionItem",
    "SVActionItem",
    "CLActionSwamp",
    "SVActionSwamp",
    "CLActionDuel",
    "SVActionDuel",
    "SVSpawnPlayer",
    "SVRespawnPlayer",
    "SVSpawnItem",
    "SVSpawnConstr",
    "SVGameEnd",
    nullptr
  };
  return names;
}

inline const char *EnumNameEvents(Events e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEvents()[index];
}

template<typename T> struct EventsTraits {
  static const Events enum_value = Events_NONE;
};

template<> struct EventsTraits<CLConnection> {
  static const Events enum_value = Events_CLConnection;
};

template<> struct EventsTraits<SVConnectionStatus> {
  static const Events enum_value = Events_SVConnectionStatus;
};

template<> struct EventsTraits<SVPlayerConnected> {
  static const Events enum_value = Events_SVPlayerConnected;
};

template<> struct EventsTraits<SVGenerateMap> {
  static const Events enum_value = Events_SVGenerateMap;
};

template<> struct EventsTraits<CLMapGenerated> {
  static const Events enum_value = Events_CLMapGenerated;
};

template<> struct EventsTraits<SVGameStart> {
  static const Events enum_value = Events_SVGameStart;
};

template<> struct EventsTraits<CLActionMove> {
  static const Events enum_value = Events_CLActionMove;
};

template<> struct EventsTraits<SVActionMove> {
  static const Events enum_value = Events_SVActionMove;
};

template<> struct EventsTraits<CLActionItem> {
  static const Events enum_value = Events_CLActionItem;
};

template<> struct EventsTraits<SVActionItem> {
  static const Events enum_value = Events_SVActionItem;
};

template<> struct EventsTraits<CLActionSwamp> {
  static const Events enum_value = Events_CLActionSwamp;
};

template<> struct EventsTraits<SVActionSwamp> {
  static const Events enum_value = Events_SVActionSwamp;
};

template<> struct EventsTraits<CLActionDuel> {
  static const Events enum_value = Events_CLActionDuel;
};

template<> struct EventsTraits<SVActionDuel> {
  static const Events enum_value = Events_SVActionDuel;
};

template<> struct EventsTraits<SVSpawnPlayer> {
  static const Events enum_value = Events_SVSpawnPlayer;
};

template<> struct EventsTraits<SVRespawnPlayer> {
  static const Events enum_value = Events_SVRespawnPlayer;
};

template<> struct EventsTraits<SVSpawnItem> {
  static const Events enum_value = Events_SVSpawnItem;
};

template<> struct EventsTraits<SVSpawnConstr> {
  static const Events enum_value = Events_SVSpawnConstr;
};

template<> struct EventsTraits<SVGameEnd> {
  static const Events enum_value = Events_SVGameEnd;
};

bool VerifyEvents(flatbuffers::Verifier &verifier, const void *obj, Events type);
bool VerifyEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct CLConnection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_NICKNAME = 6
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  const flatbuffers::String *nickname() const {
    return GetPointer<const flatbuffers::String *>(VT_NICKNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NICKNAME) &&
           verifier.Verify(nickname()) &&
           verifier.EndTable();
  }
};

struct CLConnectionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(CLConnection::VT_PLAYER_UID, player_uid, 0);
  }
  void add_nickname(flatbuffers::Offset<flatbuffers::String> nickname) {
    fbb_.AddOffset(CLConnection::VT_NICKNAME, nickname);
  }
  CLConnectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLConnectionBuilder &operator=(const CLConnectionBuilder &);
  flatbuffers::Offset<CLConnection> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<CLConnection>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLConnection> CreateCLConnection(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    flatbuffers::Offset<flatbuffers::String> nickname = 0) {
  CLConnectionBuilder builder_(_fbb);
  builder_.add_nickname(nickname);
  builder_.add_player_uid(player_uid);
  return builder_.Finish();
}

inline flatbuffers::Offset<CLConnection> CreateCLConnectionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    const char *nickname = nullptr) {
  return CreateCLConnection(
      _fbb,
      player_uid,
      nickname ? _fbb.CreateString(nickname) : 0);
}

struct SVConnectionStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_STATUS = 6
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  ConnectionStatus status() const {
    return static_cast<ConnectionStatus>(GetField<int8_t>(VT_STATUS, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           verifier.EndTable();
  }
};

struct SVConnectionStatusBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(SVConnectionStatus::VT_PLAYER_UID, player_uid, 0);
  }
  void add_status(ConnectionStatus status) {
    fbb_.AddElement<int8_t>(SVConnectionStatus::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  SVConnectionStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVConnectionStatusBuilder &operator=(const SVConnectionStatusBuilder &);
  flatbuffers::Offset<SVConnectionStatus> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<SVConnectionStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVConnectionStatus> CreateSVConnectionStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    ConnectionStatus status = ConnectionStatus_ACCEPTED) {
  SVConnectionStatusBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_status(status);
  return builder_.Finish();
}

struct SVPlayerConnected FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_NICKNAME = 6
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  const flatbuffers::String *nickname() const {
    return GetPointer<const flatbuffers::String *>(VT_NICKNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NICKNAME) &&
           verifier.Verify(nickname()) &&
           verifier.EndTable();
  }
};

struct SVPlayerConnectedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(SVPlayerConnected::VT_PLAYER_UID, player_uid, 0);
  }
  void add_nickname(flatbuffers::Offset<flatbuffers::String> nickname) {
    fbb_.AddOffset(SVPlayerConnected::VT_NICKNAME, nickname);
  }
  SVPlayerConnectedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVPlayerConnectedBuilder &operator=(const SVPlayerConnectedBuilder &);
  flatbuffers::Offset<SVPlayerConnected> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<SVPlayerConnected>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVPlayerConnected> CreateSVPlayerConnected(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    flatbuffers::Offset<flatbuffers::String> nickname = 0) {
  SVPlayerConnectedBuilder builder_(_fbb);
  builder_.add_nickname(nickname);
  builder_.add_player_uid(player_uid);
  return builder_.Finish();
}

inline flatbuffers::Offset<SVPlayerConnected> CreateSVPlayerConnectedDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    const char *nickname = nullptr) {
  return CreateSVPlayerConnected(
      _fbb,
      player_uid,
      nickname ? _fbb.CreateString(nickname) : 0);
}

struct SVGenerateMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MAP_W = 4,
    VT_ROOM_W = 6,
    VT_SEED = 8
  };
  uint16_t map_w() const {
    return GetField<uint16_t>(VT_MAP_W, 0);
  }
  uint16_t room_w() const {
    return GetField<uint16_t>(VT_ROOM_W, 0);
  }
  uint32_t seed() const {
    return GetField<uint32_t>(VT_SEED, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_MAP_W) &&
           VerifyField<uint16_t>(verifier, VT_ROOM_W) &&
           VerifyField<uint32_t>(verifier, VT_SEED) &&
           verifier.EndTable();
  }
};

struct SVGenerateMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_map_w(uint16_t map_w) {
    fbb_.AddElement<uint16_t>(SVGenerateMap::VT_MAP_W, map_w, 0);
  }
  void add_room_w(uint16_t room_w) {
    fbb_.AddElement<uint16_t>(SVGenerateMap::VT_ROOM_W, room_w, 0);
  }
  void add_seed(uint32_t seed) {
    fbb_.AddElement<uint32_t>(SVGenerateMap::VT_SEED, seed, 0);
  }
  SVGenerateMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVGenerateMapBuilder &operator=(const SVGenerateMapBuilder &);
  flatbuffers::Offset<SVGenerateMap> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<SVGenerateMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVGenerateMap> CreateSVGenerateMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t map_w = 0,
    uint16_t room_w = 0,
    uint32_t seed = 0) {
  SVGenerateMapBuilder builder_(_fbb);
  builder_.add_seed(seed);
  builder_.add_room_w(room_w);
  builder_.add_map_w(map_w);
  return builder_.Finish();
}

struct CLMapGenerated FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           verifier.EndTable();
  }
};

struct CLMapGeneratedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(CLMapGenerated::VT_PLAYER_UID, player_uid, 0);
  }
  CLMapGeneratedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLMapGeneratedBuilder &operator=(const CLMapGeneratedBuilder &);
  flatbuffers::Offset<CLMapGenerated> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<CLMapGenerated>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLMapGenerated> CreateCLMapGenerated(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0) {
  CLMapGeneratedBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  return builder_.Finish();
}

struct SVGameStart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SVGameStartBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  SVGameStartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVGameStartBuilder &operator=(const SVGameStartBuilder &);
  flatbuffers::Offset<SVGameStart> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<SVGameStart>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVGameStart> CreateSVGameStart(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SVGameStartBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CLActionMove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_X = 6,
    VT_Y = 8
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  uint16_t x() const {
    return GetField<uint16_t>(VT_X, 0);
  }
  uint16_t y() const {
    return GetField<uint16_t>(VT_Y, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<uint16_t>(verifier, VT_X) &&
           VerifyField<uint16_t>(verifier, VT_Y) &&
           verifier.EndTable();
  }
};

struct CLActionMoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(CLActionMove::VT_PLAYER_UID, player_uid, 0);
  }
  void add_x(uint16_t x) {
    fbb_.AddElement<uint16_t>(CLActionMove::VT_X, x, 0);
  }
  void add_y(uint16_t y) {
    fbb_.AddElement<uint16_t>(CLActionMove::VT_Y, y, 0);
  }
  CLActionMoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLActionMoveBuilder &operator=(const CLActionMoveBuilder &);
  flatbuffers::Offset<CLActionMove> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<CLActionMove>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLActionMove> CreateCLActionMove(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    uint16_t x = 0,
    uint16_t y = 0) {
  CLActionMoveBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct SVActionMove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_X = 6,
    VT_Y = 8
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  uint16_t x() const {
    return GetField<uint16_t>(VT_X, 0);
  }
  uint16_t y() const {
    return GetField<uint16_t>(VT_Y, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<uint16_t>(verifier, VT_X) &&
           VerifyField<uint16_t>(verifier, VT_Y) &&
           verifier.EndTable();
  }
};

struct SVActionMoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(SVActionMove::VT_PLAYER_UID, player_uid, 0);
  }
  void add_x(uint16_t x) {
    fbb_.AddElement<uint16_t>(SVActionMove::VT_X, x, 0);
  }
  void add_y(uint16_t y) {
    fbb_.AddElement<uint16_t>(SVActionMove::VT_Y, y, 0);
  }
  SVActionMoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVActionMoveBuilder &operator=(const SVActionMoveBuilder &);
  flatbuffers::Offset<SVActionMove> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<SVActionMove>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVActionMove> CreateSVActionMove(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    uint16_t x = 0,
    uint16_t y = 0) {
  SVActionMoveBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct CLActionItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_ITEM_UID = 6,
    VT_ACT_TYPE = 8
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  uint16_t item_uid() const {
    return GetField<uint16_t>(VT_ITEM_UID, 0);
  }
  ActionItemType act_type() const {
    return static_cast<ActionItemType>(GetField<int8_t>(VT_ACT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<uint16_t>(verifier, VT_ITEM_UID) &&
           VerifyField<int8_t>(verifier, VT_ACT_TYPE) &&
           verifier.EndTable();
  }
};

struct CLActionItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(CLActionItem::VT_PLAYER_UID, player_uid, 0);
  }
  void add_item_uid(uint16_t item_uid) {
    fbb_.AddElement<uint16_t>(CLActionItem::VT_ITEM_UID, item_uid, 0);
  }
  void add_act_type(ActionItemType act_type) {
    fbb_.AddElement<int8_t>(CLActionItem::VT_ACT_TYPE, static_cast<int8_t>(act_type), 0);
  }
  CLActionItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLActionItemBuilder &operator=(const CLActionItemBuilder &);
  flatbuffers::Offset<CLActionItem> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<CLActionItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLActionItem> CreateCLActionItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    uint16_t item_uid = 0,
    ActionItemType act_type = ActionItemType_TAKE) {
  CLActionItemBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_item_uid(item_uid);
  builder_.add_act_type(act_type);
  return builder_.Finish();
}

struct SVActionItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_ITEM_UID = 6,
    VT_ACT_TYPE = 8
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  uint16_t item_uid() const {
    return GetField<uint16_t>(VT_ITEM_UID, 0);
  }
  ActionItemType act_type() const {
    return static_cast<ActionItemType>(GetField<int8_t>(VT_ACT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<uint16_t>(verifier, VT_ITEM_UID) &&
           VerifyField<int8_t>(verifier, VT_ACT_TYPE) &&
           verifier.EndTable();
  }
};

struct SVActionItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(SVActionItem::VT_PLAYER_UID, player_uid, 0);
  }
  void add_item_uid(uint16_t item_uid) {
    fbb_.AddElement<uint16_t>(SVActionItem::VT_ITEM_UID, item_uid, 0);
  }
  void add_act_type(ActionItemType act_type) {
    fbb_.AddElement<int8_t>(SVActionItem::VT_ACT_TYPE, static_cast<int8_t>(act_type), 0);
  }
  SVActionItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVActionItemBuilder &operator=(const SVActionItemBuilder &);
  flatbuffers::Offset<SVActionItem> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<SVActionItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVActionItem> CreateSVActionItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    uint16_t item_uid = 0,
    ActionItemType act_type = ActionItemType_TAKE) {
  SVActionItemBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_item_uid(item_uid);
  builder_.add_act_type(act_type);
  return builder_.Finish();
}

struct CLActionSwamp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_STATUS = 6
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  ActionSwampStatus status() const {
    return static_cast<ActionSwampStatus>(GetField<int8_t>(VT_STATUS, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           verifier.EndTable();
  }
};

struct CLActionSwampBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(CLActionSwamp::VT_PLAYER_UID, player_uid, 0);
  }
  void add_status(ActionSwampStatus status) {
    fbb_.AddElement<int8_t>(CLActionSwamp::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  CLActionSwampBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLActionSwampBuilder &operator=(const CLActionSwampBuilder &);
  flatbuffers::Offset<CLActionSwamp> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<CLActionSwamp>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLActionSwamp> CreateCLActionSwamp(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    ActionSwampStatus status = ActionSwampStatus_STARTED) {
  CLActionSwampBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_status(status);
  return builder_.Finish();
}

struct SVActionSwamp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_STATUS = 6
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  ActionSwampStatus status() const {
    return static_cast<ActionSwampStatus>(GetField<int8_t>(VT_STATUS, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           verifier.EndTable();
  }
};

struct SVActionSwampBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(SVActionSwamp::VT_PLAYER_UID, player_uid, 0);
  }
  void add_status(ActionSwampStatus status) {
    fbb_.AddElement<int8_t>(SVActionSwamp::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  SVActionSwampBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVActionSwampBuilder &operator=(const SVActionSwampBuilder &);
  flatbuffers::Offset<SVActionSwamp> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<SVActionSwamp>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVActionSwamp> CreateSVActionSwamp(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    ActionSwampStatus status = ActionSwampStatus_STARTED) {
  SVActionSwampBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_status(status);
  return builder_.Finish();
}

struct CLActionDuel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER1_UID = 4,
    VT_PLAYER2_UID = 6,
    VT_TYPE = 8
  };
  uint32_t player1_uid() const {
    return GetField<uint32_t>(VT_PLAYER1_UID, 0);
  }
  uint32_t player2_uid() const {
    return GetField<uint32_t>(VT_PLAYER2_UID, 0);
  }
  ActionDuelType type() const {
    return static_cast<ActionDuelType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER1_UID) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER2_UID) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct CLActionDuelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player1_uid(uint32_t player1_uid) {
    fbb_.AddElement<uint32_t>(CLActionDuel::VT_PLAYER1_UID, player1_uid, 0);
  }
  void add_player2_uid(uint32_t player2_uid) {
    fbb_.AddElement<uint32_t>(CLActionDuel::VT_PLAYER2_UID, player2_uid, 0);
  }
  void add_type(ActionDuelType type) {
    fbb_.AddElement<int8_t>(CLActionDuel::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  CLActionDuelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLActionDuelBuilder &operator=(const CLActionDuelBuilder &);
  flatbuffers::Offset<CLActionDuel> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<CLActionDuel>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLActionDuel> CreateCLActionDuel(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player1_uid = 0,
    uint32_t player2_uid = 0,
    ActionDuelType type = ActionDuelType_STARTED) {
  CLActionDuelBuilder builder_(_fbb);
  builder_.add_player2_uid(player2_uid);
  builder_.add_player1_uid(player1_uid);
  builder_.add_type(type);
  return builder_.Finish();
}

struct SVActionDuel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER1_UID = 4,
    VT_PLAYER2_UID = 6,
    VT_TYPE = 8
  };
  uint32_t player1_uid() const {
    return GetField<uint32_t>(VT_PLAYER1_UID, 0);
  }
  uint32_t player2_uid() const {
    return GetField<uint32_t>(VT_PLAYER2_UID, 0);
  }
  ActionDuelType type() const {
    return static_cast<ActionDuelType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER1_UID) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER2_UID) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct SVActionDuelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player1_uid(uint32_t player1_uid) {
    fbb_.AddElement<uint32_t>(SVActionDuel::VT_PLAYER1_UID, player1_uid, 0);
  }
  void add_player2_uid(uint32_t player2_uid) {
    fbb_.AddElement<uint32_t>(SVActionDuel::VT_PLAYER2_UID, player2_uid, 0);
  }
  void add_type(ActionDuelType type) {
    fbb_.AddElement<int8_t>(SVActionDuel::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  SVActionDuelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVActionDuelBuilder &operator=(const SVActionDuelBuilder &);
  flatbuffers::Offset<SVActionDuel> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<SVActionDuel>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVActionDuel> CreateSVActionDuel(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player1_uid = 0,
    uint32_t player2_uid = 0,
    ActionDuelType type = ActionDuelType_STARTED) {
  SVActionDuelBuilder builder_(_fbb);
  builder_.add_player2_uid(player2_uid);
  builder_.add_player1_uid(player1_uid);
  builder_.add_type(type);
  return builder_.Finish();
}

struct SVSpawnPlayer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_HP = 10,
    VT_MAX_HP = 12
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  uint16_t x() const {
    return GetField<uint16_t>(VT_X, 0);
  }
  uint16_t y() const {
    return GetField<uint16_t>(VT_Y, 0);
  }
  uint16_t hp() const {
    return GetField<uint16_t>(VT_HP, 0);
  }
  uint16_t max_hp() const {
    return GetField<uint16_t>(VT_MAX_HP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<uint16_t>(verifier, VT_X) &&
           VerifyField<uint16_t>(verifier, VT_Y) &&
           VerifyField<uint16_t>(verifier, VT_HP) &&
           VerifyField<uint16_t>(verifier, VT_MAX_HP) &&
           verifier.EndTable();
  }
};

struct SVSpawnPlayerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(SVSpawnPlayer::VT_PLAYER_UID, player_uid, 0);
  }
  void add_x(uint16_t x) {
    fbb_.AddElement<uint16_t>(SVSpawnPlayer::VT_X, x, 0);
  }
  void add_y(uint16_t y) {
    fbb_.AddElement<uint16_t>(SVSpawnPlayer::VT_Y, y, 0);
  }
  void add_hp(uint16_t hp) {
    fbb_.AddElement<uint16_t>(SVSpawnPlayer::VT_HP, hp, 0);
  }
  void add_max_hp(uint16_t max_hp) {
    fbb_.AddElement<uint16_t>(SVSpawnPlayer::VT_MAX_HP, max_hp, 0);
  }
  SVSpawnPlayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVSpawnPlayerBuilder &operator=(const SVSpawnPlayerBuilder &);
  flatbuffers::Offset<SVSpawnPlayer> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<SVSpawnPlayer>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVSpawnPlayer> CreateSVSpawnPlayer(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    uint16_t x = 0,
    uint16_t y = 0,
    uint16_t hp = 0,
    uint16_t max_hp = 0) {
  SVSpawnPlayerBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_max_hp(max_hp);
  builder_.add_hp(hp);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct SVRespawnPlayer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_HP = 10,
    VT_MAX_HP = 12
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  uint16_t x() const {
    return GetField<uint16_t>(VT_X, 0);
  }
  uint16_t y() const {
    return GetField<uint16_t>(VT_Y, 0);
  }
  uint16_t hp() const {
    return GetField<uint16_t>(VT_HP, 0);
  }
  uint16_t max_hp() const {
    return GetField<uint16_t>(VT_MAX_HP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<uint16_t>(verifier, VT_X) &&
           VerifyField<uint16_t>(verifier, VT_Y) &&
           VerifyField<uint16_t>(verifier, VT_HP) &&
           VerifyField<uint16_t>(verifier, VT_MAX_HP) &&
           verifier.EndTable();
  }
};

struct SVRespawnPlayerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(SVRespawnPlayer::VT_PLAYER_UID, player_uid, 0);
  }
  void add_x(uint16_t x) {
    fbb_.AddElement<uint16_t>(SVRespawnPlayer::VT_X, x, 0);
  }
  void add_y(uint16_t y) {
    fbb_.AddElement<uint16_t>(SVRespawnPlayer::VT_Y, y, 0);
  }
  void add_hp(uint16_t hp) {
    fbb_.AddElement<uint16_t>(SVRespawnPlayer::VT_HP, hp, 0);
  }
  void add_max_hp(uint16_t max_hp) {
    fbb_.AddElement<uint16_t>(SVRespawnPlayer::VT_MAX_HP, max_hp, 0);
  }
  SVRespawnPlayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVRespawnPlayerBuilder &operator=(const SVRespawnPlayerBuilder &);
  flatbuffers::Offset<SVRespawnPlayer> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<SVRespawnPlayer>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVRespawnPlayer> CreateSVRespawnPlayer(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    uint16_t x = 0,
    uint16_t y = 0,
    uint16_t hp = 0,
    uint16_t max_hp = 0) {
  SVRespawnPlayerBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_max_hp(max_hp);
  builder_.add_hp(hp);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct SVSpawnItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEM_UID = 4,
    VT_ITEM_TYPE = 6,
    VT_X = 8,
    VT_Y = 10
  };
  uint16_t item_uid() const {
    return GetField<uint16_t>(VT_ITEM_UID, 0);
  }
  ItemType item_type() const {
    return static_cast<ItemType>(GetField<int8_t>(VT_ITEM_TYPE, 0));
  }
  uint16_t x() const {
    return GetField<uint16_t>(VT_X, 0);
  }
  uint16_t y() const {
    return GetField<uint16_t>(VT_Y, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ITEM_UID) &&
           VerifyField<int8_t>(verifier, VT_ITEM_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_X) &&
           VerifyField<uint16_t>(verifier, VT_Y) &&
           verifier.EndTable();
  }
};

struct SVSpawnItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_item_uid(uint16_t item_uid) {
    fbb_.AddElement<uint16_t>(SVSpawnItem::VT_ITEM_UID, item_uid, 0);
  }
  void add_item_type(ItemType item_type) {
    fbb_.AddElement<int8_t>(SVSpawnItem::VT_ITEM_TYPE, static_cast<int8_t>(item_type), 0);
  }
  void add_x(uint16_t x) {
    fbb_.AddElement<uint16_t>(SVSpawnItem::VT_X, x, 0);
  }
  void add_y(uint16_t y) {
    fbb_.AddElement<uint16_t>(SVSpawnItem::VT_Y, y, 0);
  }
  SVSpawnItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVSpawnItemBuilder &operator=(const SVSpawnItemBuilder &);
  flatbuffers::Offset<SVSpawnItem> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<SVSpawnItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVSpawnItem> CreateSVSpawnItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t item_uid = 0,
    ItemType item_type = ItemType_KEY,
    uint16_t x = 0,
    uint16_t y = 0) {
  SVSpawnItemBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_item_uid(item_uid);
  builder_.add_item_type(item_type);
  return builder_.Finish();
}

struct SVSpawnConstr FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONSTR_UID = 4,
    VT_CONSTR_TYPE = 6,
    VT_X = 8,
    VT_Y = 10
  };
  uint16_t constr_uid() const {
    return GetField<uint16_t>(VT_CONSTR_UID, 0);
  }
  ConstrType constr_type() const {
    return static_cast<ConstrType>(GetField<int8_t>(VT_CONSTR_TYPE, 0));
  }
  uint16_t x() const {
    return GetField<uint16_t>(VT_X, 0);
  }
  uint16_t y() const {
    return GetField<uint16_t>(VT_Y, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONSTR_UID) &&
           VerifyField<int8_t>(verifier, VT_CONSTR_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_X) &&
           VerifyField<uint16_t>(verifier, VT_Y) &&
           verifier.EndTable();
  }
};

struct SVSpawnConstrBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_constr_uid(uint16_t constr_uid) {
    fbb_.AddElement<uint16_t>(SVSpawnConstr::VT_CONSTR_UID, constr_uid, 0);
  }
  void add_constr_type(ConstrType constr_type) {
    fbb_.AddElement<int8_t>(SVSpawnConstr::VT_CONSTR_TYPE, static_cast<int8_t>(constr_type), 0);
  }
  void add_x(uint16_t x) {
    fbb_.AddElement<uint16_t>(SVSpawnConstr::VT_X, x, 0);
  }
  void add_y(uint16_t y) {
    fbb_.AddElement<uint16_t>(SVSpawnConstr::VT_Y, y, 0);
  }
  SVSpawnConstrBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVSpawnConstrBuilder &operator=(const SVSpawnConstrBuilder &);
  flatbuffers::Offset<SVSpawnConstr> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<SVSpawnConstr>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVSpawnConstr> CreateSVSpawnConstr(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t constr_uid = 0,
    ConstrType constr_type = ConstrType_DOOR,
    uint16_t x = 0,
    uint16_t y = 0) {
  SVSpawnConstrBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_constr_uid(constr_uid);
  builder_.add_constr_type(constr_type);
  return builder_.Finish();
}

struct SVGameEnd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           verifier.EndTable();
  }
};

struct SVGameEndBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(SVGameEnd::VT_PLAYER_UID, player_uid, 0);
  }
  SVGameEndBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVGameEndBuilder &operator=(const SVGameEndBuilder &);
  flatbuffers::Offset<SVGameEnd> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<SVGameEnd>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVGameEnd> CreateSVGameEnd(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0) {
  SVGameEndBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  return builder_.Finish();
}

struct Event FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENT_TYPE = 4,
    VT_EVENT = 6
  };
  Events event_type() const {
    return static_cast<Events>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  const void *event() const {
    return GetPointer<const void *>(VT_EVENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_EVENT) &&
           VerifyEvents(verifier, event(), event_type()) &&
           verifier.EndTable();
  }
};

struct EventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_event_type(Events event_type) {
    fbb_.AddElement<uint8_t>(Event::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event(flatbuffers::Offset<void> event) {
    fbb_.AddOffset(Event::VT_EVENT, event);
  }
  EventBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventBuilder &operator=(const EventBuilder &);
  flatbuffers::Offset<Event> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Event>(end);
    return o;
  }
};

inline flatbuffers::Offset<Event> CreateEvent(
    flatbuffers::FlatBufferBuilder &_fbb,
    Events event_type = Events_NONE,
    flatbuffers::Offset<void> event = 0) {
  EventBuilder builder_(_fbb);
  builder_.add_event(event);
  builder_.add_event_type(event_type);
  return builder_.Finish();
}

inline bool VerifyEvents(flatbuffers::Verifier &verifier, const void *obj, Events type) {
  switch (type) {
    case Events_NONE: {
      return true;
    }
    case Events_CLConnection: {
      auto ptr = reinterpret_cast<const CLConnection *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVConnectionStatus: {
      auto ptr = reinterpret_cast<const SVConnectionStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVPlayerConnected: {
      auto ptr = reinterpret_cast<const SVPlayerConnected *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVGenerateMap: {
      auto ptr = reinterpret_cast<const SVGenerateMap *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_CLMapGenerated: {
      auto ptr = reinterpret_cast<const CLMapGenerated *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVGameStart: {
      auto ptr = reinterpret_cast<const SVGameStart *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_CLActionMove: {
      auto ptr = reinterpret_cast<const CLActionMove *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVActionMove: {
      auto ptr = reinterpret_cast<const SVActionMove *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_CLActionItem: {
      auto ptr = reinterpret_cast<const CLActionItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVActionItem: {
      auto ptr = reinterpret_cast<const SVActionItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_CLActionSwamp: {
      auto ptr = reinterpret_cast<const CLActionSwamp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVActionSwamp: {
      auto ptr = reinterpret_cast<const SVActionSwamp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_CLActionDuel: {
      auto ptr = reinterpret_cast<const CLActionDuel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVActionDuel: {
      auto ptr = reinterpret_cast<const SVActionDuel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVSpawnPlayer: {
      auto ptr = reinterpret_cast<const SVSpawnPlayer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVRespawnPlayer: {
      auto ptr = reinterpret_cast<const SVRespawnPlayer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVSpawnItem: {
      auto ptr = reinterpret_cast<const SVSpawnItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVSpawnConstr: {
      auto ptr = reinterpret_cast<const SVSpawnConstr *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVGameEnd: {
      auto ptr = reinterpret_cast<const SVGameEnd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEvents(
        verifier,  values->Get(i), types->GetEnum<Events>(i))) {
      return false;
    }
  }
  return true;
}

inline const GameEvent::Event *GetEvent(const void *buf) {
  return flatbuffers::GetRoot<GameEvent::Event>(buf);
}

inline bool VerifyEventBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<GameEvent::Event>(nullptr);
}

inline void FinishEventBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<GameEvent::Event> root) {
  fbb.Finish(root);
}

}  // namespace GameEvent

#endif  // FLATBUFFERS_GENERATED_GSNET_GAMEEVENT_H_
