// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GSNET_GAMEEVENT_H_
#define FLATBUFFERS_GENERATED_GSNET_GAMEEVENT_H_

#include "flatbuffers/flatbuffers.h"

namespace GameEvent {

struct CLConnection;

struct SVConnectionStatus;

struct SVPlayerConnected;

struct SVHeroPickStage;

struct CLHeroPick;

struct SVHeroPick;

struct CLReadyToStart;

struct SVReadyToStart;

struct SVGenerateMap;

struct CLMapGenerated;

struct SVGameStart;

struct CLActionMove;

struct SVActionMove;

struct CLActionItem;

struct SVActionItem;

struct CLActionSpell;

struct SVActionSpell;

struct CLActionSwamp;

struct SVActionSwamp;

struct CLActionDuel;

struct SVActionDuel;

struct CLActionMap;

struct SVActionMap;

struct SVSpawnPlayer;

struct SVSpawnMonster;

struct SVRespawnPlayer;

struct SVSpawnItem;

struct SVSpawnConstr;

struct SVGameEnd;

struct Message;

enum ConnectionStatus {
  ConnectionStatus_ACCEPTED = 0,
  ConnectionStatus_REFUSED = 1,
  ConnectionStatus_MIN = ConnectionStatus_ACCEPTED,
  ConnectionStatus_MAX = ConnectionStatus_REFUSED
};

inline const char **EnumNamesConnectionStatus() {
  static const char *names[] = {
    "ACCEPTED",
    "REFUSED",
    nullptr
  };
  return names;
}

inline const char *EnumNameConnectionStatus(ConnectionStatus e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesConnectionStatus()[index];
}

enum HeroType {
  HeroType_AIR_ELEMENTALIST = 0,
  HeroType_WATER_ELEMENTALIST = 1,
  HeroType_FIRE_ELEMENTALIST = 2,
  HeroType_EARTH_ELEMENTALIST = 3,
  HeroType_RANDOM = 4,
  HeroType_MIN = HeroType_AIR_ELEMENTALIST,
  HeroType_MAX = HeroType_RANDOM
};

inline const char **EnumNamesHeroType() {
  static const char *names[] = {
    "AIR_ELEMENTALIST",
    "WATER_ELEMENTALIST",
    "FIRE_ELEMENTALIST",
    "EARTH_ELEMENTALIST",
    "RANDOM",
    nullptr
  };
  return names;
}

inline const char *EnumNameHeroType(HeroType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesHeroType()[index];
}

enum ActionMoveTarget {
  ActionMoveTarget_PLAYER = 0,
  ActionMoveTarget_MONSTER = 1,
  ActionMoveTarget_MIN = ActionMoveTarget_PLAYER,
  ActionMoveTarget_MAX = ActionMoveTarget_MONSTER
};

inline const char **EnumNamesActionMoveTarget() {
  static const char *names[] = {
    "PLAYER",
    "MONSTER",
    nullptr
  };
  return names;
}

inline const char *EnumNameActionMoveTarget(ActionMoveTarget e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesActionMoveTarget()[index];
}

enum ActionItemType {
  ActionItemType_TAKE = 0,
  ActionItemType_DROP = 1,
  ActionItemType_USE = 2,
  ActionItemType_MIN = ActionItemType_TAKE,
  ActionItemType_MAX = ActionItemType_USE
};

inline const char **EnumNamesActionItemType() {
  static const char *names[] = {
    "TAKE",
    "DROP",
    "USE",
    nullptr
  };
  return names;
}

inline const char *EnumNameActionItemType(ActionItemType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesActionItemType()[index];
}

enum ActionSpellTarget {
  ActionSpellTarget_TARGET_PLAYER = 0,
  ActionSpellTarget_TARGET_MONSTER = 1,
  ActionSpellTarget_TARGET_POINT = 2,
  ActionSpellTarget_MIN = ActionSpellTarget_TARGET_PLAYER,
  ActionSpellTarget_MAX = ActionSpellTarget_TARGET_POINT
};

inline const char **EnumNamesActionSpellTarget() {
  static const char *names[] = {
    "TARGET_PLAYER",
    "TARGET_MONSTER",
    "TARGET_POINT",
    nullptr
  };
  return names;
}

inline const char *EnumNameActionSpellTarget(ActionSpellTarget e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesActionSpellTarget()[index];
}

enum ActionSwampStatus {
  ActionSwampStatus_STARTED = 0,
  ActionSwampStatus_ESCAPED = 1,
  ActionSwampStatus_DIED = 2,
  ActionSwampStatus_MIN = ActionSwampStatus_STARTED,
  ActionSwampStatus_MAX = ActionSwampStatus_DIED
};

inline const char **EnumNamesActionSwampStatus() {
  static const char *names[] = {
    "STARTED",
    "ESCAPED",
    "DIED",
    nullptr
  };
  return names;
}

inline const char *EnumNameActionSwampStatus(ActionSwampStatus e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesActionSwampStatus()[index];
}

enum ActionDuelType {
  ActionDuelType_STARTED = 0,
  ActionDuelType_ATTACK = 1,
  ActionDuelType_ESCAPE = 2,
  ActionDuelType_KILL = 3,
  ActionDuelType_MIN = ActionDuelType_STARTED,
  ActionDuelType_MAX = ActionDuelType_KILL
};

inline const char **EnumNamesActionDuelType() {
  static const char *names[] = {
    "STARTED",
    "ATTACK",
    "ESCAPE",
    "KILL",
    nullptr
  };
  return names;
}

inline const char *EnumNameActionDuelType(ActionDuelType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesActionDuelType()[index];
}

enum ActionDuelTarget {
  ActionDuelTarget_PLAYER = 0,
  ActionDuelTarget_MONSTER = 1,
  ActionDuelTarget_MIN = ActionDuelTarget_PLAYER,
  ActionDuelTarget_MAX = ActionDuelTarget_MONSTER
};

inline const char **EnumNamesActionDuelTarget() {
  static const char *names[] = {
    "PLAYER",
    "MONSTER",
    nullptr
  };
  return names;
}

inline const char *EnumNameActionDuelTarget(ActionDuelTarget e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesActionDuelTarget()[index];
}

enum ActionMapType {
  ActionMapType_CREATE_BLOCK = 0,
  ActionMapType_DESTROY_BLOCK = 1,
  ActionMapType_MIN = ActionMapType_CREATE_BLOCK,
  ActionMapType_MAX = ActionMapType_DESTROY_BLOCK
};

inline const char **EnumNamesActionMapType() {
  static const char *names[] = {
    "CREATE_BLOCK",
    "DESTROY_BLOCK",
    nullptr
  };
  return names;
}

inline const char *EnumNameActionMapType(ActionMapType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesActionMapType()[index];
}

enum ItemType {
  ItemType_KEY = 0,
  ItemType_SWORD = 1,
  ItemType_MIN = ItemType_KEY,
  ItemType_MAX = ItemType_SWORD
};

inline const char **EnumNamesItemType() {
  static const char *names[] = {
    "KEY",
    "SWORD",
    nullptr
  };
  return names;
}

inline const char *EnumNameItemType(ItemType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesItemType()[index];
}

enum ConstrType {
  ConstrType_DOOR = 0,
  ConstrType_GRAVEYARD = 1,
  ConstrType_SWAMP = 2,
  ConstrType_MIN = ConstrType_DOOR,
  ConstrType_MAX = ConstrType_SWAMP
};

inline const char **EnumNamesConstrType() {
  static const char *names[] = {
    "DOOR",
    "GRAVEYARD",
    "SWAMP",
    nullptr
  };
  return names;
}

inline const char *EnumNameConstrType(ConstrType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesConstrType()[index];
}

enum Events {
  Events_NONE = 0,
  Events_CLConnection = 1,
  Events_SVConnectionStatus = 2,
  Events_SVPlayerConnected = 3,
  Events_SVHeroPickStage = 4,
  Events_CLHeroPick = 5,
  Events_SVHeroPick = 6,
  Events_CLReadyToStart = 7,
  Events_SVReadyToStart = 8,
  Events_SVGenerateMap = 9,
  Events_CLMapGenerated = 10,
  Events_SVGameStart = 11,
  Events_CLActionMove = 12,
  Events_SVActionMove = 13,
  Events_CLActionItem = 14,
  Events_SVActionItem = 15,
  Events_CLActionSwamp = 16,
  Events_SVActionSwamp = 17,
  Events_CLActionDuel = 18,
  Events_SVActionDuel = 19,
  Events_CLActionSpell = 20,
  Events_SVActionSpell = 21,
  Events_CLActionMap = 22,
  Events_SVActionMap = 23,
  Events_SVSpawnPlayer = 24,
  Events_SVRespawnPlayer = 25,
  Events_SVSpawnMonster = 26,
  Events_SVSpawnItem = 27,
  Events_SVSpawnConstr = 28,
  Events_SVGameEnd = 29,
  Events_MIN = Events_NONE,
  Events_MAX = Events_SVGameEnd
};

inline const char **EnumNamesEvents() {
  static const char *names[] = {
    "NONE",
    "CLConnection",
    "SVConnectionStatus",
    "SVPlayerConnected",
    "SVHeroPickStage",
    "CLHeroPick",
    "SVHeroPick",
    "CLReadyToStart",
    "SVReadyToStart",
    "SVGenerateMap",
    "CLMapGenerated",
    "SVGameStart",
    "CLActionMove",
    "SVActionMove",
    "CLActionItem",
    "SVActionItem",
    "CLActionSwamp",
    "SVActionSwamp",
    "CLActionDuel",
    "SVActionDuel",
    "CLActionSpell",
    "SVActionSpell",
    "CLActionMap",
    "SVActionMap",
    "SVSpawnPlayer",
    "SVRespawnPlayer",
    "SVSpawnMonster",
    "SVSpawnItem",
    "SVSpawnConstr",
    "SVGameEnd",
    nullptr
  };
  return names;
}

inline const char *EnumNameEvents(Events e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEvents()[index];
}

template<typename T> struct EventsTraits {
  static const Events enum_value = Events_NONE;
};

template<> struct EventsTraits<CLConnection> {
  static const Events enum_value = Events_CLConnection;
};

template<> struct EventsTraits<SVConnectionStatus> {
  static const Events enum_value = Events_SVConnectionStatus;
};

template<> struct EventsTraits<SVPlayerConnected> {
  static const Events enum_value = Events_SVPlayerConnected;
};

template<> struct EventsTraits<SVHeroPickStage> {
  static const Events enum_value = Events_SVHeroPickStage;
};

template<> struct EventsTraits<CLHeroPick> {
  static const Events enum_value = Events_CLHeroPick;
};

template<> struct EventsTraits<SVHeroPick> {
  static const Events enum_value = Events_SVHeroPick;
};

template<> struct EventsTraits<CLReadyToStart> {
  static const Events enum_value = Events_CLReadyToStart;
};

template<> struct EventsTraits<SVReadyToStart> {
  static const Events enum_value = Events_SVReadyToStart;
};

template<> struct EventsTraits<SVGenerateMap> {
  static const Events enum_value = Events_SVGenerateMap;
};

template<> struct EventsTraits<CLMapGenerated> {
  static const Events enum_value = Events_CLMapGenerated;
};

template<> struct EventsTraits<SVGameStart> {
  static const Events enum_value = Events_SVGameStart;
};

template<> struct EventsTraits<CLActionMove> {
  static const Events enum_value = Events_CLActionMove;
};

template<> struct EventsTraits<SVActionMove> {
  static const Events enum_value = Events_SVActionMove;
};

template<> struct EventsTraits<CLActionItem> {
  static const Events enum_value = Events_CLActionItem;
};

template<> struct EventsTraits<SVActionItem> {
  static const Events enum_value = Events_SVActionItem;
};

template<> struct EventsTraits<CLActionSwamp> {
  static const Events enum_value = Events_CLActionSwamp;
};

template<> struct EventsTraits<SVActionSwamp> {
  static const Events enum_value = Events_SVActionSwamp;
};

template<> struct EventsTraits<CLActionDuel> {
  static const Events enum_value = Events_CLActionDuel;
};

template<> struct EventsTraits<SVActionDuel> {
  static const Events enum_value = Events_SVActionDuel;
};

template<> struct EventsTraits<CLActionSpell> {
  static const Events enum_value = Events_CLActionSpell;
};

template<> struct EventsTraits<SVActionSpell> {
  static const Events enum_value = Events_SVActionSpell;
};

template<> struct EventsTraits<CLActionMap> {
  static const Events enum_value = Events_CLActionMap;
};

template<> struct EventsTraits<SVActionMap> {
  static const Events enum_value = Events_SVActionMap;
};

template<> struct EventsTraits<SVSpawnPlayer> {
  static const Events enum_value = Events_SVSpawnPlayer;
};

template<> struct EventsTraits<SVRespawnPlayer> {
  static const Events enum_value = Events_SVRespawnPlayer;
};

template<> struct EventsTraits<SVSpawnMonster> {
  static const Events enum_value = Events_SVSpawnMonster;
};

template<> struct EventsTraits<SVSpawnItem> {
  static const Events enum_value = Events_SVSpawnItem;
};

template<> struct EventsTraits<SVSpawnConstr> {
  static const Events enum_value = Events_SVSpawnConstr;
};

template<> struct EventsTraits<SVGameEnd> {
  static const Events enum_value = Events_SVGameEnd;
};

bool VerifyEvents(flatbuffers::Verifier &verifier, const void *obj, Events type);
bool VerifyEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct CLConnection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_NICKNAME = 6
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  const flatbuffers::String *nickname() const {
    return GetPointer<const flatbuffers::String *>(VT_NICKNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NICKNAME) &&
           verifier.Verify(nickname()) &&
           verifier.EndTable();
  }
};

struct CLConnectionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(CLConnection::VT_PLAYER_UID, player_uid, 0);
  }
  void add_nickname(flatbuffers::Offset<flatbuffers::String> nickname) {
    fbb_.AddOffset(CLConnection::VT_NICKNAME, nickname);
  }
  CLConnectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLConnectionBuilder &operator=(const CLConnectionBuilder &);
  flatbuffers::Offset<CLConnection> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<CLConnection>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLConnection> CreateCLConnection(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    flatbuffers::Offset<flatbuffers::String> nickname = 0) {
  CLConnectionBuilder builder_(_fbb);
  builder_.add_nickname(nickname);
  builder_.add_player_uid(player_uid);
  return builder_.Finish();
}

inline flatbuffers::Offset<CLConnection> CreateCLConnectionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    const char *nickname = nullptr) {
  return CreateCLConnection(
      _fbb,
      player_uid,
      nickname ? _fbb.CreateString(nickname) : 0);
}

struct SVConnectionStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_STATUS = 6
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  ConnectionStatus status() const {
    return static_cast<ConnectionStatus>(GetField<int8_t>(VT_STATUS, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           verifier.EndTable();
  }
};

struct SVConnectionStatusBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(SVConnectionStatus::VT_PLAYER_UID, player_uid, 0);
  }
  void add_status(ConnectionStatus status) {
    fbb_.AddElement<int8_t>(SVConnectionStatus::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  SVConnectionStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVConnectionStatusBuilder &operator=(const SVConnectionStatusBuilder &);
  flatbuffers::Offset<SVConnectionStatus> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<SVConnectionStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVConnectionStatus> CreateSVConnectionStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    ConnectionStatus status = ConnectionStatus_ACCEPTED) {
  SVConnectionStatusBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_status(status);
  return builder_.Finish();
}

struct SVPlayerConnected FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_NICKNAME = 6
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  const flatbuffers::String *nickname() const {
    return GetPointer<const flatbuffers::String *>(VT_NICKNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NICKNAME) &&
           verifier.Verify(nickname()) &&
           verifier.EndTable();
  }
};

struct SVPlayerConnectedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(SVPlayerConnected::VT_PLAYER_UID, player_uid, 0);
  }
  void add_nickname(flatbuffers::Offset<flatbuffers::String> nickname) {
    fbb_.AddOffset(SVPlayerConnected::VT_NICKNAME, nickname);
  }
  SVPlayerConnectedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVPlayerConnectedBuilder &operator=(const SVPlayerConnectedBuilder &);
  flatbuffers::Offset<SVPlayerConnected> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<SVPlayerConnected>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVPlayerConnected> CreateSVPlayerConnected(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    flatbuffers::Offset<flatbuffers::String> nickname = 0) {
  SVPlayerConnectedBuilder builder_(_fbb);
  builder_.add_nickname(nickname);
  builder_.add_player_uid(player_uid);
  return builder_.Finish();
}

inline flatbuffers::Offset<SVPlayerConnected> CreateSVPlayerConnectedDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    const char *nickname = nullptr) {
  return CreateSVPlayerConnected(
      _fbb,
      player_uid,
      nickname ? _fbb.CreateString(nickname) : 0);
}

struct SVHeroPickStage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SVHeroPickStageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  SVHeroPickStageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVHeroPickStageBuilder &operator=(const SVHeroPickStageBuilder &);
  flatbuffers::Offset<SVHeroPickStage> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<SVHeroPickStage>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVHeroPickStage> CreateSVHeroPickStage(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SVHeroPickStageBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CLHeroPick FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_HERO_TYPE = 6
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  HeroType hero_type() const {
    return static_cast<HeroType>(GetField<int8_t>(VT_HERO_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<int8_t>(verifier, VT_HERO_TYPE) &&
           verifier.EndTable();
  }
};

struct CLHeroPickBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(CLHeroPick::VT_PLAYER_UID, player_uid, 0);
  }
  void add_hero_type(HeroType hero_type) {
    fbb_.AddElement<int8_t>(CLHeroPick::VT_HERO_TYPE, static_cast<int8_t>(hero_type), 0);
  }
  CLHeroPickBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLHeroPickBuilder &operator=(const CLHeroPickBuilder &);
  flatbuffers::Offset<CLHeroPick> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<CLHeroPick>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLHeroPick> CreateCLHeroPick(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    HeroType hero_type = HeroType_AIR_ELEMENTALIST) {
  CLHeroPickBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_hero_type(hero_type);
  return builder_.Finish();
}

struct SVHeroPick FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_HERO_TYPE = 6
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  HeroType hero_type() const {
    return static_cast<HeroType>(GetField<int8_t>(VT_HERO_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<int8_t>(verifier, VT_HERO_TYPE) &&
           verifier.EndTable();
  }
};

struct SVHeroPickBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(SVHeroPick::VT_PLAYER_UID, player_uid, 0);
  }
  void add_hero_type(HeroType hero_type) {
    fbb_.AddElement<int8_t>(SVHeroPick::VT_HERO_TYPE, static_cast<int8_t>(hero_type), 0);
  }
  SVHeroPickBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVHeroPickBuilder &operator=(const SVHeroPickBuilder &);
  flatbuffers::Offset<SVHeroPick> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<SVHeroPick>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVHeroPick> CreateSVHeroPick(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    HeroType hero_type = HeroType_AIR_ELEMENTALIST) {
  SVHeroPickBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_hero_type(hero_type);
  return builder_.Finish();
}

struct CLReadyToStart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           verifier.EndTable();
  }
};

struct CLReadyToStartBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(CLReadyToStart::VT_PLAYER_UID, player_uid, 0);
  }
  CLReadyToStartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLReadyToStartBuilder &operator=(const CLReadyToStartBuilder &);
  flatbuffers::Offset<CLReadyToStart> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<CLReadyToStart>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLReadyToStart> CreateCLReadyToStart(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0) {
  CLReadyToStartBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  return builder_.Finish();
}

struct SVReadyToStart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           verifier.EndTable();
  }
};

struct SVReadyToStartBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(SVReadyToStart::VT_PLAYER_UID, player_uid, 0);
  }
  SVReadyToStartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVReadyToStartBuilder &operator=(const SVReadyToStartBuilder &);
  flatbuffers::Offset<SVReadyToStart> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<SVReadyToStart>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVReadyToStart> CreateSVReadyToStart(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0) {
  SVReadyToStartBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  return builder_.Finish();
}

struct SVGenerateMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MAP_W = 4,
    VT_ROOM_W = 6,
    VT_SEED = 8
  };
  uint16_t map_w() const {
    return GetField<uint16_t>(VT_MAP_W, 0);
  }
  uint16_t room_w() const {
    return GetField<uint16_t>(VT_ROOM_W, 0);
  }
  uint32_t seed() const {
    return GetField<uint32_t>(VT_SEED, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_MAP_W) &&
           VerifyField<uint16_t>(verifier, VT_ROOM_W) &&
           VerifyField<uint32_t>(verifier, VT_SEED) &&
           verifier.EndTable();
  }
};

struct SVGenerateMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_map_w(uint16_t map_w) {
    fbb_.AddElement<uint16_t>(SVGenerateMap::VT_MAP_W, map_w, 0);
  }
  void add_room_w(uint16_t room_w) {
    fbb_.AddElement<uint16_t>(SVGenerateMap::VT_ROOM_W, room_w, 0);
  }
  void add_seed(uint32_t seed) {
    fbb_.AddElement<uint32_t>(SVGenerateMap::VT_SEED, seed, 0);
  }
  SVGenerateMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVGenerateMapBuilder &operator=(const SVGenerateMapBuilder &);
  flatbuffers::Offset<SVGenerateMap> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<SVGenerateMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVGenerateMap> CreateSVGenerateMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t map_w = 0,
    uint16_t room_w = 0,
    uint32_t seed = 0) {
  SVGenerateMapBuilder builder_(_fbb);
  builder_.add_seed(seed);
  builder_.add_room_w(room_w);
  builder_.add_map_w(map_w);
  return builder_.Finish();
}

struct CLMapGenerated FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           verifier.EndTable();
  }
};

struct CLMapGeneratedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(CLMapGenerated::VT_PLAYER_UID, player_uid, 0);
  }
  CLMapGeneratedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLMapGeneratedBuilder &operator=(const CLMapGeneratedBuilder &);
  flatbuffers::Offset<CLMapGenerated> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<CLMapGenerated>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLMapGenerated> CreateCLMapGenerated(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0) {
  CLMapGeneratedBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  return builder_.Finish();
}

struct SVGameStart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SVGameStartBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  SVGameStartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVGameStartBuilder &operator=(const SVGameStartBuilder &);
  flatbuffers::Offset<SVGameStart> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<SVGameStart>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVGameStart> CreateSVGameStart(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SVGameStartBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CLActionMove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TARGET_UID = 4,
    VT_TARGET_TYPE = 6,
    VT_X = 8,
    VT_Y = 10
  };
  uint32_t target_uid() const {
    return GetField<uint32_t>(VT_TARGET_UID, 0);
  }
  ActionMoveTarget target_type() const {
    return static_cast<ActionMoveTarget>(GetField<int8_t>(VT_TARGET_TYPE, 0));
  }
  uint16_t x() const {
    return GetField<uint16_t>(VT_X, 0);
  }
  uint16_t y() const {
    return GetField<uint16_t>(VT_Y, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TARGET_UID) &&
           VerifyField<int8_t>(verifier, VT_TARGET_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_X) &&
           VerifyField<uint16_t>(verifier, VT_Y) &&
           verifier.EndTable();
  }
};

struct CLActionMoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_target_uid(uint32_t target_uid) {
    fbb_.AddElement<uint32_t>(CLActionMove::VT_TARGET_UID, target_uid, 0);
  }
  void add_target_type(ActionMoveTarget target_type) {
    fbb_.AddElement<int8_t>(CLActionMove::VT_TARGET_TYPE, static_cast<int8_t>(target_type), 0);
  }
  void add_x(uint16_t x) {
    fbb_.AddElement<uint16_t>(CLActionMove::VT_X, x, 0);
  }
  void add_y(uint16_t y) {
    fbb_.AddElement<uint16_t>(CLActionMove::VT_Y, y, 0);
  }
  CLActionMoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLActionMoveBuilder &operator=(const CLActionMoveBuilder &);
  flatbuffers::Offset<CLActionMove> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<CLActionMove>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLActionMove> CreateCLActionMove(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t target_uid = 0,
    ActionMoveTarget target_type = ActionMoveTarget_PLAYER,
    uint16_t x = 0,
    uint16_t y = 0) {
  CLActionMoveBuilder builder_(_fbb);
  builder_.add_target_uid(target_uid);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_target_type(target_type);
  return builder_.Finish();
}

struct SVActionMove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TARGET_UID = 4,
    VT_TARGET_TYPE = 6,
    VT_X = 8,
    VT_Y = 10
  };
  uint32_t target_uid() const {
    return GetField<uint32_t>(VT_TARGET_UID, 0);
  }
  ActionMoveTarget target_type() const {
    return static_cast<ActionMoveTarget>(GetField<int8_t>(VT_TARGET_TYPE, 0));
  }
  uint16_t x() const {
    return GetField<uint16_t>(VT_X, 0);
  }
  uint16_t y() const {
    return GetField<uint16_t>(VT_Y, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TARGET_UID) &&
           VerifyField<int8_t>(verifier, VT_TARGET_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_X) &&
           VerifyField<uint16_t>(verifier, VT_Y) &&
           verifier.EndTable();
  }
};

struct SVActionMoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_target_uid(uint32_t target_uid) {
    fbb_.AddElement<uint32_t>(SVActionMove::VT_TARGET_UID, target_uid, 0);
  }
  void add_target_type(ActionMoveTarget target_type) {
    fbb_.AddElement<int8_t>(SVActionMove::VT_TARGET_TYPE, static_cast<int8_t>(target_type), 0);
  }
  void add_x(uint16_t x) {
    fbb_.AddElement<uint16_t>(SVActionMove::VT_X, x, 0);
  }
  void add_y(uint16_t y) {
    fbb_.AddElement<uint16_t>(SVActionMove::VT_Y, y, 0);
  }
  SVActionMoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVActionMoveBuilder &operator=(const SVActionMoveBuilder &);
  flatbuffers::Offset<SVActionMove> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<SVActionMove>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVActionMove> CreateSVActionMove(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t target_uid = 0,
    ActionMoveTarget target_type = ActionMoveTarget_PLAYER,
    uint16_t x = 0,
    uint16_t y = 0) {
  SVActionMoveBuilder builder_(_fbb);
  builder_.add_target_uid(target_uid);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_target_type(target_type);
  return builder_.Finish();
}

struct CLActionItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_ITEM_UID = 6,
    VT_ACT_TYPE = 8
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  uint16_t item_uid() const {
    return GetField<uint16_t>(VT_ITEM_UID, 0);
  }
  ActionItemType act_type() const {
    return static_cast<ActionItemType>(GetField<int8_t>(VT_ACT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<uint16_t>(verifier, VT_ITEM_UID) &&
           VerifyField<int8_t>(verifier, VT_ACT_TYPE) &&
           verifier.EndTable();
  }
};

struct CLActionItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(CLActionItem::VT_PLAYER_UID, player_uid, 0);
  }
  void add_item_uid(uint16_t item_uid) {
    fbb_.AddElement<uint16_t>(CLActionItem::VT_ITEM_UID, item_uid, 0);
  }
  void add_act_type(ActionItemType act_type) {
    fbb_.AddElement<int8_t>(CLActionItem::VT_ACT_TYPE, static_cast<int8_t>(act_type), 0);
  }
  CLActionItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLActionItemBuilder &operator=(const CLActionItemBuilder &);
  flatbuffers::Offset<CLActionItem> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<CLActionItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLActionItem> CreateCLActionItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    uint16_t item_uid = 0,
    ActionItemType act_type = ActionItemType_TAKE) {
  CLActionItemBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_item_uid(item_uid);
  builder_.add_act_type(act_type);
  return builder_.Finish();
}

struct SVActionItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_ITEM_UID = 6,
    VT_ACT_TYPE = 8
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  uint16_t item_uid() const {
    return GetField<uint16_t>(VT_ITEM_UID, 0);
  }
  ActionItemType act_type() const {
    return static_cast<ActionItemType>(GetField<int8_t>(VT_ACT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<uint16_t>(verifier, VT_ITEM_UID) &&
           VerifyField<int8_t>(verifier, VT_ACT_TYPE) &&
           verifier.EndTable();
  }
};

struct SVActionItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(SVActionItem::VT_PLAYER_UID, player_uid, 0);
  }
  void add_item_uid(uint16_t item_uid) {
    fbb_.AddElement<uint16_t>(SVActionItem::VT_ITEM_UID, item_uid, 0);
  }
  void add_act_type(ActionItemType act_type) {
    fbb_.AddElement<int8_t>(SVActionItem::VT_ACT_TYPE, static_cast<int8_t>(act_type), 0);
  }
  SVActionItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVActionItemBuilder &operator=(const SVActionItemBuilder &);
  flatbuffers::Offset<SVActionItem> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<SVActionItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVActionItem> CreateSVActionItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    uint16_t item_uid = 0,
    ActionItemType act_type = ActionItemType_TAKE) {
  SVActionItemBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_item_uid(item_uid);
  builder_.add_act_type(act_type);
  return builder_.Finish();
}

struct CLActionSpell FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_SPELL_ID = 6,
    VT_SPELL_TARGET = 8,
    VT_X_OR_ID = 10,
    VT_Y = 12
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  uint16_t spell_id() const {
    return GetField<uint16_t>(VT_SPELL_ID, 0);
  }
  ActionSpellTarget spell_target() const {
    return static_cast<ActionSpellTarget>(GetField<int8_t>(VT_SPELL_TARGET, 0));
  }
  uint32_t x_or_id() const {
    return GetField<uint32_t>(VT_X_OR_ID, 0);
  }
  uint32_t y() const {
    return GetField<uint32_t>(VT_Y, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<uint16_t>(verifier, VT_SPELL_ID) &&
           VerifyField<int8_t>(verifier, VT_SPELL_TARGET) &&
           VerifyField<uint32_t>(verifier, VT_X_OR_ID) &&
           VerifyField<uint32_t>(verifier, VT_Y) &&
           verifier.EndTable();
  }
};

struct CLActionSpellBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(CLActionSpell::VT_PLAYER_UID, player_uid, 0);
  }
  void add_spell_id(uint16_t spell_id) {
    fbb_.AddElement<uint16_t>(CLActionSpell::VT_SPELL_ID, spell_id, 0);
  }
  void add_spell_target(ActionSpellTarget spell_target) {
    fbb_.AddElement<int8_t>(CLActionSpell::VT_SPELL_TARGET, static_cast<int8_t>(spell_target), 0);
  }
  void add_x_or_id(uint32_t x_or_id) {
    fbb_.AddElement<uint32_t>(CLActionSpell::VT_X_OR_ID, x_or_id, 0);
  }
  void add_y(uint32_t y) {
    fbb_.AddElement<uint32_t>(CLActionSpell::VT_Y, y, 0);
  }
  CLActionSpellBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLActionSpellBuilder &operator=(const CLActionSpellBuilder &);
  flatbuffers::Offset<CLActionSpell> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<CLActionSpell>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLActionSpell> CreateCLActionSpell(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    uint16_t spell_id = 0,
    ActionSpellTarget spell_target = ActionSpellTarget_TARGET_PLAYER,
    uint32_t x_or_id = 0,
    uint32_t y = 0) {
  CLActionSpellBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x_or_id(x_or_id);
  builder_.add_player_uid(player_uid);
  builder_.add_spell_id(spell_id);
  builder_.add_spell_target(spell_target);
  return builder_.Finish();
}

struct SVActionSpell FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_SPELL_ID = 6,
    VT_SPELL_TARGET = 8,
    VT_POINT_X = 10,
    VT_POINT_Y = 12
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  uint16_t spell_id() const {
    return GetField<uint16_t>(VT_SPELL_ID, 0);
  }
  ActionSpellTarget spell_target() const {
    return static_cast<ActionSpellTarget>(GetField<int8_t>(VT_SPELL_TARGET, 0));
  }
  uint32_t point_x() const {
    return GetField<uint32_t>(VT_POINT_X, 0);
  }
  uint32_t point_y() const {
    return GetField<uint32_t>(VT_POINT_Y, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<uint16_t>(verifier, VT_SPELL_ID) &&
           VerifyField<int8_t>(verifier, VT_SPELL_TARGET) &&
           VerifyField<uint32_t>(verifier, VT_POINT_X) &&
           VerifyField<uint32_t>(verifier, VT_POINT_Y) &&
           verifier.EndTable();
  }
};

struct SVActionSpellBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(SVActionSpell::VT_PLAYER_UID, player_uid, 0);
  }
  void add_spell_id(uint16_t spell_id) {
    fbb_.AddElement<uint16_t>(SVActionSpell::VT_SPELL_ID, spell_id, 0);
  }
  void add_spell_target(ActionSpellTarget spell_target) {
    fbb_.AddElement<int8_t>(SVActionSpell::VT_SPELL_TARGET, static_cast<int8_t>(spell_target), 0);
  }
  void add_point_x(uint32_t point_x) {
    fbb_.AddElement<uint32_t>(SVActionSpell::VT_POINT_X, point_x, 0);
  }
  void add_point_y(uint32_t point_y) {
    fbb_.AddElement<uint32_t>(SVActionSpell::VT_POINT_Y, point_y, 0);
  }
  SVActionSpellBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVActionSpellBuilder &operator=(const SVActionSpellBuilder &);
  flatbuffers::Offset<SVActionSpell> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<SVActionSpell>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVActionSpell> CreateSVActionSpell(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    uint16_t spell_id = 0,
    ActionSpellTarget spell_target = ActionSpellTarget_TARGET_PLAYER,
    uint32_t point_x = 0,
    uint32_t point_y = 0) {
  SVActionSpellBuilder builder_(_fbb);
  builder_.add_point_y(point_y);
  builder_.add_point_x(point_x);
  builder_.add_player_uid(player_uid);
  builder_.add_spell_id(spell_id);
  builder_.add_spell_target(spell_target);
  return builder_.Finish();
}

struct CLActionSwamp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_STATUS = 6
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  ActionSwampStatus status() const {
    return static_cast<ActionSwampStatus>(GetField<int8_t>(VT_STATUS, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           verifier.EndTable();
  }
};

struct CLActionSwampBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(CLActionSwamp::VT_PLAYER_UID, player_uid, 0);
  }
  void add_status(ActionSwampStatus status) {
    fbb_.AddElement<int8_t>(CLActionSwamp::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  CLActionSwampBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLActionSwampBuilder &operator=(const CLActionSwampBuilder &);
  flatbuffers::Offset<CLActionSwamp> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<CLActionSwamp>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLActionSwamp> CreateCLActionSwamp(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    ActionSwampStatus status = ActionSwampStatus_STARTED) {
  CLActionSwampBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_status(status);
  return builder_.Finish();
}

struct SVActionSwamp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_STATUS = 6
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  ActionSwampStatus status() const {
    return static_cast<ActionSwampStatus>(GetField<int8_t>(VT_STATUS, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<int8_t>(verifier, VT_STATUS) &&
           verifier.EndTable();
  }
};

struct SVActionSwampBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(SVActionSwamp::VT_PLAYER_UID, player_uid, 0);
  }
  void add_status(ActionSwampStatus status) {
    fbb_.AddElement<int8_t>(SVActionSwamp::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  SVActionSwampBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVActionSwampBuilder &operator=(const SVActionSwampBuilder &);
  flatbuffers::Offset<SVActionSwamp> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<SVActionSwamp>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVActionSwamp> CreateSVActionSwamp(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    ActionSwampStatus status = ActionSwampStatus_STARTED) {
  SVActionSwampBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_status(status);
  return builder_.Finish();
}

struct CLActionDuel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TARGET1_UID = 4,
    VT_TARGET1_TYPE = 6,
    VT_TARGET2_UID = 8,
    VT_TARGET2_TYPE = 10,
    VT_ACT_TYPE = 12,
    VT_DAMAGE = 14
  };
  uint32_t target1_uid() const {
    return GetField<uint32_t>(VT_TARGET1_UID, 0);
  }
  ActionDuelTarget target1_type() const {
    return static_cast<ActionDuelTarget>(GetField<int8_t>(VT_TARGET1_TYPE, 0));
  }
  uint32_t target2_uid() const {
    return GetField<uint32_t>(VT_TARGET2_UID, 0);
  }
  ActionDuelTarget target2_type() const {
    return static_cast<ActionDuelTarget>(GetField<int8_t>(VT_TARGET2_TYPE, 0));
  }
  ActionDuelType act_type() const {
    return static_cast<ActionDuelType>(GetField<int8_t>(VT_ACT_TYPE, 0));
  }
  uint16_t damage() const {
    return GetField<uint16_t>(VT_DAMAGE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TARGET1_UID) &&
           VerifyField<int8_t>(verifier, VT_TARGET1_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_TARGET2_UID) &&
           VerifyField<int8_t>(verifier, VT_TARGET2_TYPE) &&
           VerifyField<int8_t>(verifier, VT_ACT_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_DAMAGE) &&
           verifier.EndTable();
  }
};

struct CLActionDuelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_target1_uid(uint32_t target1_uid) {
    fbb_.AddElement<uint32_t>(CLActionDuel::VT_TARGET1_UID, target1_uid, 0);
  }
  void add_target1_type(ActionDuelTarget target1_type) {
    fbb_.AddElement<int8_t>(CLActionDuel::VT_TARGET1_TYPE, static_cast<int8_t>(target1_type), 0);
  }
  void add_target2_uid(uint32_t target2_uid) {
    fbb_.AddElement<uint32_t>(CLActionDuel::VT_TARGET2_UID, target2_uid, 0);
  }
  void add_target2_type(ActionDuelTarget target2_type) {
    fbb_.AddElement<int8_t>(CLActionDuel::VT_TARGET2_TYPE, static_cast<int8_t>(target2_type), 0);
  }
  void add_act_type(ActionDuelType act_type) {
    fbb_.AddElement<int8_t>(CLActionDuel::VT_ACT_TYPE, static_cast<int8_t>(act_type), 0);
  }
  void add_damage(uint16_t damage) {
    fbb_.AddElement<uint16_t>(CLActionDuel::VT_DAMAGE, damage, 0);
  }
  CLActionDuelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLActionDuelBuilder &operator=(const CLActionDuelBuilder &);
  flatbuffers::Offset<CLActionDuel> Finish() {
    const auto end = fbb_.EndTable(start_, 6);
    auto o = flatbuffers::Offset<CLActionDuel>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLActionDuel> CreateCLActionDuel(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t target1_uid = 0,
    ActionDuelTarget target1_type = ActionDuelTarget_PLAYER,
    uint32_t target2_uid = 0,
    ActionDuelTarget target2_type = ActionDuelTarget_PLAYER,
    ActionDuelType act_type = ActionDuelType_STARTED,
    uint16_t damage = 0) {
  CLActionDuelBuilder builder_(_fbb);
  builder_.add_target2_uid(target2_uid);
  builder_.add_target1_uid(target1_uid);
  builder_.add_damage(damage);
  builder_.add_act_type(act_type);
  builder_.add_target2_type(target2_type);
  builder_.add_target1_type(target1_type);
  return builder_.Finish();
}

struct SVActionDuel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TARGET1_UID = 4,
    VT_TARGET1_TYPE = 6,
    VT_TARGET2_UID = 8,
    VT_TARGET2_TYPE = 10,
    VT_ACT_TYPE = 12,
    VT_DAMAGE = 14
  };
  uint32_t target1_uid() const {
    return GetField<uint32_t>(VT_TARGET1_UID, 0);
  }
  ActionDuelTarget target1_type() const {
    return static_cast<ActionDuelTarget>(GetField<int8_t>(VT_TARGET1_TYPE, 0));
  }
  uint32_t target2_uid() const {
    return GetField<uint32_t>(VT_TARGET2_UID, 0);
  }
  ActionDuelTarget target2_type() const {
    return static_cast<ActionDuelTarget>(GetField<int8_t>(VT_TARGET2_TYPE, 0));
  }
  ActionDuelType act_type() const {
    return static_cast<ActionDuelType>(GetField<int8_t>(VT_ACT_TYPE, 0));
  }
  uint16_t damage() const {
    return GetField<uint16_t>(VT_DAMAGE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TARGET1_UID) &&
           VerifyField<int8_t>(verifier, VT_TARGET1_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_TARGET2_UID) &&
           VerifyField<int8_t>(verifier, VT_TARGET2_TYPE) &&
           VerifyField<int8_t>(verifier, VT_ACT_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_DAMAGE) &&
           verifier.EndTable();
  }
};

struct SVActionDuelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_target1_uid(uint32_t target1_uid) {
    fbb_.AddElement<uint32_t>(SVActionDuel::VT_TARGET1_UID, target1_uid, 0);
  }
  void add_target1_type(ActionDuelTarget target1_type) {
    fbb_.AddElement<int8_t>(SVActionDuel::VT_TARGET1_TYPE, static_cast<int8_t>(target1_type), 0);
  }
  void add_target2_uid(uint32_t target2_uid) {
    fbb_.AddElement<uint32_t>(SVActionDuel::VT_TARGET2_UID, target2_uid, 0);
  }
  void add_target2_type(ActionDuelTarget target2_type) {
    fbb_.AddElement<int8_t>(SVActionDuel::VT_TARGET2_TYPE, static_cast<int8_t>(target2_type), 0);
  }
  void add_act_type(ActionDuelType act_type) {
    fbb_.AddElement<int8_t>(SVActionDuel::VT_ACT_TYPE, static_cast<int8_t>(act_type), 0);
  }
  void add_damage(uint16_t damage) {
    fbb_.AddElement<uint16_t>(SVActionDuel::VT_DAMAGE, damage, 0);
  }
  SVActionDuelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVActionDuelBuilder &operator=(const SVActionDuelBuilder &);
  flatbuffers::Offset<SVActionDuel> Finish() {
    const auto end = fbb_.EndTable(start_, 6);
    auto o = flatbuffers::Offset<SVActionDuel>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVActionDuel> CreateSVActionDuel(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t target1_uid = 0,
    ActionDuelTarget target1_type = ActionDuelTarget_PLAYER,
    uint32_t target2_uid = 0,
    ActionDuelTarget target2_type = ActionDuelTarget_PLAYER,
    ActionDuelType act_type = ActionDuelType_STARTED,
    uint16_t damage = 0) {
  SVActionDuelBuilder builder_(_fbb);
  builder_.add_target2_uid(target2_uid);
  builder_.add_target1_uid(target1_uid);
  builder_.add_damage(damage);
  builder_.add_act_type(act_type);
  builder_.add_target2_type(target2_type);
  builder_.add_target1_type(target1_type);
  return builder_.Finish();
}

struct CLActionMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_ACT_TYPE = 6,
    VT_X = 8,
    VT_Y = 10
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  ActionMapType act_type() const {
    return static_cast<ActionMapType>(GetField<int8_t>(VT_ACT_TYPE, 0));
  }
  uint16_t x() const {
    return GetField<uint16_t>(VT_X, 0);
  }
  uint16_t y() const {
    return GetField<uint16_t>(VT_Y, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<int8_t>(verifier, VT_ACT_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_X) &&
           VerifyField<uint16_t>(verifier, VT_Y) &&
           verifier.EndTable();
  }
};

struct CLActionMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(CLActionMap::VT_PLAYER_UID, player_uid, 0);
  }
  void add_act_type(ActionMapType act_type) {
    fbb_.AddElement<int8_t>(CLActionMap::VT_ACT_TYPE, static_cast<int8_t>(act_type), 0);
  }
  void add_x(uint16_t x) {
    fbb_.AddElement<uint16_t>(CLActionMap::VT_X, x, 0);
  }
  void add_y(uint16_t y) {
    fbb_.AddElement<uint16_t>(CLActionMap::VT_Y, y, 0);
  }
  CLActionMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLActionMapBuilder &operator=(const CLActionMapBuilder &);
  flatbuffers::Offset<CLActionMap> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<CLActionMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLActionMap> CreateCLActionMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    ActionMapType act_type = ActionMapType_CREATE_BLOCK,
    uint16_t x = 0,
    uint16_t y = 0) {
  CLActionMapBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_act_type(act_type);
  return builder_.Finish();
}

struct SVActionMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_ACT_TYPE = 6,
    VT_X = 8,
    VT_Y = 10
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  ActionMapType act_type() const {
    return static_cast<ActionMapType>(GetField<int8_t>(VT_ACT_TYPE, 0));
  }
  uint16_t x() const {
    return GetField<uint16_t>(VT_X, 0);
  }
  uint16_t y() const {
    return GetField<uint16_t>(VT_Y, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<int8_t>(verifier, VT_ACT_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_X) &&
           VerifyField<uint16_t>(verifier, VT_Y) &&
           verifier.EndTable();
  }
};

struct SVActionMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(SVActionMap::VT_PLAYER_UID, player_uid, 0);
  }
  void add_act_type(ActionMapType act_type) {
    fbb_.AddElement<int8_t>(SVActionMap::VT_ACT_TYPE, static_cast<int8_t>(act_type), 0);
  }
  void add_x(uint16_t x) {
    fbb_.AddElement<uint16_t>(SVActionMap::VT_X, x, 0);
  }
  void add_y(uint16_t y) {
    fbb_.AddElement<uint16_t>(SVActionMap::VT_Y, y, 0);
  }
  SVActionMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVActionMapBuilder &operator=(const SVActionMapBuilder &);
  flatbuffers::Offset<SVActionMap> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<SVActionMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVActionMap> CreateSVActionMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    ActionMapType act_type = ActionMapType_CREATE_BLOCK,
    uint16_t x = 0,
    uint16_t y = 0) {
  SVActionMapBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_act_type(act_type);
  return builder_.Finish();
}

struct SVSpawnPlayer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_HP = 10,
    VT_MAX_HP = 12
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  uint16_t x() const {
    return GetField<uint16_t>(VT_X, 0);
  }
  uint16_t y() const {
    return GetField<uint16_t>(VT_Y, 0);
  }
  uint16_t hp() const {
    return GetField<uint16_t>(VT_HP, 0);
  }
  uint16_t max_hp() const {
    return GetField<uint16_t>(VT_MAX_HP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<uint16_t>(verifier, VT_X) &&
           VerifyField<uint16_t>(verifier, VT_Y) &&
           VerifyField<uint16_t>(verifier, VT_HP) &&
           VerifyField<uint16_t>(verifier, VT_MAX_HP) &&
           verifier.EndTable();
  }
};

struct SVSpawnPlayerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(SVSpawnPlayer::VT_PLAYER_UID, player_uid, 0);
  }
  void add_x(uint16_t x) {
    fbb_.AddElement<uint16_t>(SVSpawnPlayer::VT_X, x, 0);
  }
  void add_y(uint16_t y) {
    fbb_.AddElement<uint16_t>(SVSpawnPlayer::VT_Y, y, 0);
  }
  void add_hp(uint16_t hp) {
    fbb_.AddElement<uint16_t>(SVSpawnPlayer::VT_HP, hp, 0);
  }
  void add_max_hp(uint16_t max_hp) {
    fbb_.AddElement<uint16_t>(SVSpawnPlayer::VT_MAX_HP, max_hp, 0);
  }
  SVSpawnPlayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVSpawnPlayerBuilder &operator=(const SVSpawnPlayerBuilder &);
  flatbuffers::Offset<SVSpawnPlayer> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<SVSpawnPlayer>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVSpawnPlayer> CreateSVSpawnPlayer(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    uint16_t x = 0,
    uint16_t y = 0,
    uint16_t hp = 0,
    uint16_t max_hp = 0) {
  SVSpawnPlayerBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_max_hp(max_hp);
  builder_.add_hp(hp);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct SVSpawnMonster FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MONSTER_UID = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_HP = 10,
    VT_MAX_HP = 12
  };
  uint16_t monster_uid() const {
    return GetField<uint16_t>(VT_MONSTER_UID, 0);
  }
  uint16_t x() const {
    return GetField<uint16_t>(VT_X, 0);
  }
  uint16_t y() const {
    return GetField<uint16_t>(VT_Y, 0);
  }
  uint16_t hp() const {
    return GetField<uint16_t>(VT_HP, 0);
  }
  uint16_t max_hp() const {
    return GetField<uint16_t>(VT_MAX_HP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_MONSTER_UID) &&
           VerifyField<uint16_t>(verifier, VT_X) &&
           VerifyField<uint16_t>(verifier, VT_Y) &&
           VerifyField<uint16_t>(verifier, VT_HP) &&
           VerifyField<uint16_t>(verifier, VT_MAX_HP) &&
           verifier.EndTable();
  }
};

struct SVSpawnMonsterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_monster_uid(uint16_t monster_uid) {
    fbb_.AddElement<uint16_t>(SVSpawnMonster::VT_MONSTER_UID, monster_uid, 0);
  }
  void add_x(uint16_t x) {
    fbb_.AddElement<uint16_t>(SVSpawnMonster::VT_X, x, 0);
  }
  void add_y(uint16_t y) {
    fbb_.AddElement<uint16_t>(SVSpawnMonster::VT_Y, y, 0);
  }
  void add_hp(uint16_t hp) {
    fbb_.AddElement<uint16_t>(SVSpawnMonster::VT_HP, hp, 0);
  }
  void add_max_hp(uint16_t max_hp) {
    fbb_.AddElement<uint16_t>(SVSpawnMonster::VT_MAX_HP, max_hp, 0);
  }
  SVSpawnMonsterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVSpawnMonsterBuilder &operator=(const SVSpawnMonsterBuilder &);
  flatbuffers::Offset<SVSpawnMonster> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<SVSpawnMonster>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVSpawnMonster> CreateSVSpawnMonster(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t monster_uid = 0,
    uint16_t x = 0,
    uint16_t y = 0,
    uint16_t hp = 0,
    uint16_t max_hp = 0) {
  SVSpawnMonsterBuilder builder_(_fbb);
  builder_.add_max_hp(max_hp);
  builder_.add_hp(hp);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_monster_uid(monster_uid);
  return builder_.Finish();
}

struct SVRespawnPlayer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_HP = 10,
    VT_MAX_HP = 12
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  uint16_t x() const {
    return GetField<uint16_t>(VT_X, 0);
  }
  uint16_t y() const {
    return GetField<uint16_t>(VT_Y, 0);
  }
  uint16_t hp() const {
    return GetField<uint16_t>(VT_HP, 0);
  }
  uint16_t max_hp() const {
    return GetField<uint16_t>(VT_MAX_HP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<uint16_t>(verifier, VT_X) &&
           VerifyField<uint16_t>(verifier, VT_Y) &&
           VerifyField<uint16_t>(verifier, VT_HP) &&
           VerifyField<uint16_t>(verifier, VT_MAX_HP) &&
           verifier.EndTable();
  }
};

struct SVRespawnPlayerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(SVRespawnPlayer::VT_PLAYER_UID, player_uid, 0);
  }
  void add_x(uint16_t x) {
    fbb_.AddElement<uint16_t>(SVRespawnPlayer::VT_X, x, 0);
  }
  void add_y(uint16_t y) {
    fbb_.AddElement<uint16_t>(SVRespawnPlayer::VT_Y, y, 0);
  }
  void add_hp(uint16_t hp) {
    fbb_.AddElement<uint16_t>(SVRespawnPlayer::VT_HP, hp, 0);
  }
  void add_max_hp(uint16_t max_hp) {
    fbb_.AddElement<uint16_t>(SVRespawnPlayer::VT_MAX_HP, max_hp, 0);
  }
  SVRespawnPlayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVRespawnPlayerBuilder &operator=(const SVRespawnPlayerBuilder &);
  flatbuffers::Offset<SVRespawnPlayer> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<SVRespawnPlayer>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVRespawnPlayer> CreateSVRespawnPlayer(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    uint16_t x = 0,
    uint16_t y = 0,
    uint16_t hp = 0,
    uint16_t max_hp = 0) {
  SVRespawnPlayerBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_max_hp(max_hp);
  builder_.add_hp(hp);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct SVSpawnItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEM_UID = 4,
    VT_ITEM_TYPE = 6,
    VT_X = 8,
    VT_Y = 10
  };
  uint16_t item_uid() const {
    return GetField<uint16_t>(VT_ITEM_UID, 0);
  }
  ItemType item_type() const {
    return static_cast<ItemType>(GetField<int8_t>(VT_ITEM_TYPE, 0));
  }
  uint16_t x() const {
    return GetField<uint16_t>(VT_X, 0);
  }
  uint16_t y() const {
    return GetField<uint16_t>(VT_Y, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ITEM_UID) &&
           VerifyField<int8_t>(verifier, VT_ITEM_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_X) &&
           VerifyField<uint16_t>(verifier, VT_Y) &&
           verifier.EndTable();
  }
};

struct SVSpawnItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_item_uid(uint16_t item_uid) {
    fbb_.AddElement<uint16_t>(SVSpawnItem::VT_ITEM_UID, item_uid, 0);
  }
  void add_item_type(ItemType item_type) {
    fbb_.AddElement<int8_t>(SVSpawnItem::VT_ITEM_TYPE, static_cast<int8_t>(item_type), 0);
  }
  void add_x(uint16_t x) {
    fbb_.AddElement<uint16_t>(SVSpawnItem::VT_X, x, 0);
  }
  void add_y(uint16_t y) {
    fbb_.AddElement<uint16_t>(SVSpawnItem::VT_Y, y, 0);
  }
  SVSpawnItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVSpawnItemBuilder &operator=(const SVSpawnItemBuilder &);
  flatbuffers::Offset<SVSpawnItem> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<SVSpawnItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVSpawnItem> CreateSVSpawnItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t item_uid = 0,
    ItemType item_type = ItemType_KEY,
    uint16_t x = 0,
    uint16_t y = 0) {
  SVSpawnItemBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_item_uid(item_uid);
  builder_.add_item_type(item_type);
  return builder_.Finish();
}

struct SVSpawnConstr FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONSTR_UID = 4,
    VT_CONSTR_TYPE = 6,
    VT_X = 8,
    VT_Y = 10
  };
  uint16_t constr_uid() const {
    return GetField<uint16_t>(VT_CONSTR_UID, 0);
  }
  ConstrType constr_type() const {
    return static_cast<ConstrType>(GetField<int8_t>(VT_CONSTR_TYPE, 0));
  }
  uint16_t x() const {
    return GetField<uint16_t>(VT_X, 0);
  }
  uint16_t y() const {
    return GetField<uint16_t>(VT_Y, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_CONSTR_UID) &&
           VerifyField<int8_t>(verifier, VT_CONSTR_TYPE) &&
           VerifyField<uint16_t>(verifier, VT_X) &&
           VerifyField<uint16_t>(verifier, VT_Y) &&
           verifier.EndTable();
  }
};

struct SVSpawnConstrBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_constr_uid(uint16_t constr_uid) {
    fbb_.AddElement<uint16_t>(SVSpawnConstr::VT_CONSTR_UID, constr_uid, 0);
  }
  void add_constr_type(ConstrType constr_type) {
    fbb_.AddElement<int8_t>(SVSpawnConstr::VT_CONSTR_TYPE, static_cast<int8_t>(constr_type), 0);
  }
  void add_x(uint16_t x) {
    fbb_.AddElement<uint16_t>(SVSpawnConstr::VT_X, x, 0);
  }
  void add_y(uint16_t y) {
    fbb_.AddElement<uint16_t>(SVSpawnConstr::VT_Y, y, 0);
  }
  SVSpawnConstrBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVSpawnConstrBuilder &operator=(const SVSpawnConstrBuilder &);
  flatbuffers::Offset<SVSpawnConstr> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<SVSpawnConstr>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVSpawnConstr> CreateSVSpawnConstr(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t constr_uid = 0,
    ConstrType constr_type = ConstrType_DOOR,
    uint16_t x = 0,
    uint16_t y = 0) {
  SVSpawnConstrBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_constr_uid(constr_uid);
  builder_.add_constr_type(constr_type);
  return builder_.Finish();
}

struct SVGameEnd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           verifier.EndTable();
  }
};

struct SVGameEndBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(SVGameEnd::VT_PLAYER_UID, player_uid, 0);
  }
  SVGameEndBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVGameEndBuilder &operator=(const SVGameEndBuilder &);
  flatbuffers::Offset<SVGameEnd> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<SVGameEnd>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVGameEnd> CreateSVGameEnd(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0) {
  SVGameEndBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  return builder_.Finish();
}

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENT_TYPE = 4,
    VT_EVENT = 6
  };
  Events event_type() const {
    return static_cast<Events>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  const void *event() const {
    return GetPointer<const void *>(VT_EVENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_EVENT) &&
           VerifyEvents(verifier, event(), event_type()) &&
           verifier.EndTable();
  }
};

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_event_type(Events event_type) {
    fbb_.AddElement<uint8_t>(Message::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event(flatbuffers::Offset<void> event) {
    fbb_.AddOffset(Message::VT_EVENT, event);
  }
  MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    Events event_type = Events_NONE,
    flatbuffers::Offset<void> event = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_event(event);
  builder_.add_event_type(event_type);
  return builder_.Finish();
}

inline bool VerifyEvents(flatbuffers::Verifier &verifier, const void *obj, Events type) {
  switch (type) {
    case Events_NONE: {
      return true;
    }
    case Events_CLConnection: {
      auto ptr = reinterpret_cast<const CLConnection *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVConnectionStatus: {
      auto ptr = reinterpret_cast<const SVConnectionStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVPlayerConnected: {
      auto ptr = reinterpret_cast<const SVPlayerConnected *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVHeroPickStage: {
      auto ptr = reinterpret_cast<const SVHeroPickStage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_CLHeroPick: {
      auto ptr = reinterpret_cast<const CLHeroPick *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVHeroPick: {
      auto ptr = reinterpret_cast<const SVHeroPick *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_CLReadyToStart: {
      auto ptr = reinterpret_cast<const CLReadyToStart *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVReadyToStart: {
      auto ptr = reinterpret_cast<const SVReadyToStart *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVGenerateMap: {
      auto ptr = reinterpret_cast<const SVGenerateMap *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_CLMapGenerated: {
      auto ptr = reinterpret_cast<const CLMapGenerated *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVGameStart: {
      auto ptr = reinterpret_cast<const SVGameStart *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_CLActionMove: {
      auto ptr = reinterpret_cast<const CLActionMove *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVActionMove: {
      auto ptr = reinterpret_cast<const SVActionMove *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_CLActionItem: {
      auto ptr = reinterpret_cast<const CLActionItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVActionItem: {
      auto ptr = reinterpret_cast<const SVActionItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_CLActionSwamp: {
      auto ptr = reinterpret_cast<const CLActionSwamp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVActionSwamp: {
      auto ptr = reinterpret_cast<const SVActionSwamp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_CLActionDuel: {
      auto ptr = reinterpret_cast<const CLActionDuel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVActionDuel: {
      auto ptr = reinterpret_cast<const SVActionDuel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_CLActionSpell: {
      auto ptr = reinterpret_cast<const CLActionSpell *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVActionSpell: {
      auto ptr = reinterpret_cast<const SVActionSpell *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_CLActionMap: {
      auto ptr = reinterpret_cast<const CLActionMap *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVActionMap: {
      auto ptr = reinterpret_cast<const SVActionMap *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVSpawnPlayer: {
      auto ptr = reinterpret_cast<const SVSpawnPlayer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVRespawnPlayer: {
      auto ptr = reinterpret_cast<const SVRespawnPlayer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVSpawnMonster: {
      auto ptr = reinterpret_cast<const SVSpawnMonster *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVSpawnItem: {
      auto ptr = reinterpret_cast<const SVSpawnItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVSpawnConstr: {
      auto ptr = reinterpret_cast<const SVSpawnConstr *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Events_SVGameEnd: {
      auto ptr = reinterpret_cast<const SVGameEnd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEvents(
        verifier,  values->Get(i), types->GetEnum<Events>(i))) {
      return false;
    }
  }
  return true;
}

inline const GameEvent::Message *GetMessage(const void *buf) {
  return flatbuffers::GetRoot<GameEvent::Message>(buf);
}

inline bool VerifyMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<GameEvent::Message>(nullptr);
}

inline void FinishMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<GameEvent::Message> root) {
  fbb.Finish(root);
}

}  // namespace GameEvent

#endif  // FLATBUFFERS_GENERATED_GSNET_GAMEEVENT_H_
