// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MSNET_MSNET_H_
#define FLATBUFFERS_GENERATED_MSNET_MSNET_H_

#include "flatbuffers/flatbuffers.h"

namespace MSNet {

struct CLPing;

struct MSPing;

struct CLRegister;

struct SVRegister;

struct CLLogin;

struct SVLogin;

struct CLFindGame;

struct SVFindGame;

struct MSGameFound;

struct MSEvent;

enum RegistrationStatus {
  RegistrationStatus_SUCCESS = 0,
  RegistrationStatus_EMAIL_TAKEN = 1,
  RegistrationStatus_MIN = RegistrationStatus_SUCCESS,
  RegistrationStatus_MAX = RegistrationStatus_EMAIL_TAKEN
};

inline const char **EnumNamesRegistrationStatus() {
  static const char *names[] = {
    "SUCCESS",
    "EMAIL_TAKEN",
    nullptr
  };
  return names;
}

inline const char *EnumNameRegistrationStatus(RegistrationStatus e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesRegistrationStatus()[index];
}

enum LoginStatus {
  LoginStatus_SUCCESS = 0,
  LoginStatus_WRONG_INPUT = 1,
  LoginStatus_MIN = LoginStatus_SUCCESS,
  LoginStatus_MAX = LoginStatus_WRONG_INPUT
};

inline const char **EnumNamesLoginStatus() {
  static const char *names[] = {
    "SUCCESS",
    "WRONG_INPUT",
    nullptr
  };
  return names;
}

inline const char *EnumNameLoginStatus(LoginStatus e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesLoginStatus()[index];
}

enum ConnectionResponse {
  ConnectionResponse_ACCEPTED = 0,
  ConnectionResponse_REFUSED = 1,
  ConnectionResponse_MIN = ConnectionResponse_ACCEPTED,
  ConnectionResponse_MAX = ConnectionResponse_REFUSED
};

inline const char **EnumNamesConnectionResponse() {
  static const char *names[] = {
    "ACCEPTED",
    "REFUSED",
    nullptr
  };
  return names;
}

inline const char *EnumNameConnectionResponse(ConnectionResponse e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesConnectionResponse()[index];
}

enum MSEvents {
  MSEvents_NONE = 0,
  MSEvents_CLPing = 1,
  MSEvents_MSPing = 2,
  MSEvents_CLRegister = 3,
  MSEvents_SVRegister = 4,
  MSEvents_CLLogin = 5,
  MSEvents_SVLogin = 6,
  MSEvents_CLFindGame = 7,
  MSEvents_SVFindGame = 8,
  MSEvents_MSGameFound = 9,
  MSEvents_MIN = MSEvents_NONE,
  MSEvents_MAX = MSEvents_MSGameFound
};

inline const char **EnumNamesMSEvents() {
  static const char *names[] = {
    "NONE",
    "CLPing",
    "MSPing",
    "CLRegister",
    "SVRegister",
    "CLLogin",
    "SVLogin",
    "CLFindGame",
    "SVFindGame",
    "MSGameFound",
    nullptr
  };
  return names;
}

inline const char *EnumNameMSEvents(MSEvents e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMSEvents()[index];
}

template<typename T> struct MSEventsTraits {
  static const MSEvents enum_value = MSEvents_NONE;
};

template<> struct MSEventsTraits<CLPing> {
  static const MSEvents enum_value = MSEvents_CLPing;
};

template<> struct MSEventsTraits<MSPing> {
  static const MSEvents enum_value = MSEvents_MSPing;
};

template<> struct MSEventsTraits<CLRegister> {
  static const MSEvents enum_value = MSEvents_CLRegister;
};

template<> struct MSEventsTraits<SVRegister> {
  static const MSEvents enum_value = MSEvents_SVRegister;
};

template<> struct MSEventsTraits<CLLogin> {
  static const MSEvents enum_value = MSEvents_CLLogin;
};

template<> struct MSEventsTraits<SVLogin> {
  static const MSEvents enum_value = MSEvents_SVLogin;
};

template<> struct MSEventsTraits<CLFindGame> {
  static const MSEvents enum_value = MSEvents_CLFindGame;
};

template<> struct MSEventsTraits<SVFindGame> {
  static const MSEvents enum_value = MSEvents_SVFindGame;
};

template<> struct MSEventsTraits<MSGameFound> {
  static const MSEvents enum_value = MSEvents_MSGameFound;
};

bool VerifyMSEvents(flatbuffers::Verifier &verifier, const void *obj, MSEvents type);
bool VerifyMSEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct CLPing FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CLPingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  CLPingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLPingBuilder &operator=(const CLPingBuilder &);
  flatbuffers::Offset<CLPing> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<CLPing>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLPing> CreateCLPing(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CLPingBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MSPing FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MSPingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  MSPingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MSPingBuilder &operator=(const MSPingBuilder &);
  flatbuffers::Offset<MSPing> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<MSPing>(end);
    return o;
  }
};

inline flatbuffers::Offset<MSPing> CreateMSPing(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MSPingBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CLRegister FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EMAIL = 4,
    VT_PASSWORD = 6
  };
  const flatbuffers::String *email() const {
    return GetPointer<const flatbuffers::String *>(VT_EMAIL);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_EMAIL) &&
           verifier.Verify(email()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PASSWORD) &&
           verifier.Verify(password()) &&
           verifier.EndTable();
  }
};

struct CLRegisterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_email(flatbuffers::Offset<flatbuffers::String> email) {
    fbb_.AddOffset(CLRegister::VT_EMAIL, email);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(CLRegister::VT_PASSWORD, password);
  }
  CLRegisterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLRegisterBuilder &operator=(const CLRegisterBuilder &);
  flatbuffers::Offset<CLRegister> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<CLRegister>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLRegister> CreateCLRegister(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> email = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  CLRegisterBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_email(email);
  return builder_.Finish();
}

inline flatbuffers::Offset<CLRegister> CreateCLRegisterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *email = nullptr,
    const char *password = nullptr) {
  return CreateCLRegister(
      _fbb,
      email ? _fbb.CreateString(email) : 0,
      password ? _fbb.CreateString(password) : 0);
}

struct SVRegister FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESPONSE = 4
  };
  RegistrationStatus response() const {
    return static_cast<RegistrationStatus>(GetField<int8_t>(VT_RESPONSE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_RESPONSE) &&
           verifier.EndTable();
  }
};

struct SVRegisterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_response(RegistrationStatus response) {
    fbb_.AddElement<int8_t>(SVRegister::VT_RESPONSE, static_cast<int8_t>(response), 0);
  }
  SVRegisterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVRegisterBuilder &operator=(const SVRegisterBuilder &);
  flatbuffers::Offset<SVRegister> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<SVRegister>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVRegister> CreateSVRegister(
    flatbuffers::FlatBufferBuilder &_fbb,
    RegistrationStatus response = RegistrationStatus_SUCCESS) {
  SVRegisterBuilder builder_(_fbb);
  builder_.add_response(response);
  return builder_.Finish();
}

struct CLLogin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EMAIL = 4,
    VT_PASSWORD = 6
  };
  const flatbuffers::String *email() const {
    return GetPointer<const flatbuffers::String *>(VT_EMAIL);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_EMAIL) &&
           verifier.Verify(email()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PASSWORD) &&
           verifier.Verify(password()) &&
           verifier.EndTable();
  }
};

struct CLLoginBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_email(flatbuffers::Offset<flatbuffers::String> email) {
    fbb_.AddOffset(CLLogin::VT_EMAIL, email);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(CLLogin::VT_PASSWORD, password);
  }
  CLLoginBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLLoginBuilder &operator=(const CLLoginBuilder &);
  flatbuffers::Offset<CLLogin> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<CLLogin>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLLogin> CreateCLLogin(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> email = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  CLLoginBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_email(email);
  return builder_.Finish();
}

inline flatbuffers::Offset<CLLogin> CreateCLLoginDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *email = nullptr,
    const char *password = nullptr) {
  return CreateCLLogin(
      _fbb,
      email ? _fbb.CreateString(email) : 0,
      password ? _fbb.CreateString(password) : 0);
}

struct SVLogin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESPONSE = 4
  };
  LoginStatus response() const {
    return static_cast<LoginStatus>(GetField<int8_t>(VT_RESPONSE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_RESPONSE) &&
           verifier.EndTable();
  }
};

struct SVLoginBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_response(LoginStatus response) {
    fbb_.AddElement<int8_t>(SVLogin::VT_RESPONSE, static_cast<int8_t>(response), 0);
  }
  SVLoginBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVLoginBuilder &operator=(const SVLoginBuilder &);
  flatbuffers::Offset<SVLogin> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<SVLogin>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVLogin> CreateSVLogin(
    flatbuffers::FlatBufferBuilder &_fbb,
    LoginStatus response = LoginStatus_SUCCESS) {
  SVLoginBuilder builder_(_fbb);
  builder_.add_response(response);
  return builder_.Finish();
}

struct CLFindGame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_CL_VERSION_MAJOR = 6,
    VT_CL_VERSION_MINOR = 8,
    VT_CL_VERSION_BUILD = 10
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  int8_t cl_version_major() const {
    return GetField<int8_t>(VT_CL_VERSION_MAJOR, 0);
  }
  int8_t cl_version_minor() const {
    return GetField<int8_t>(VT_CL_VERSION_MINOR, 0);
  }
  int8_t cl_version_build() const {
    return GetField<int8_t>(VT_CL_VERSION_BUILD, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<int8_t>(verifier, VT_CL_VERSION_MAJOR) &&
           VerifyField<int8_t>(verifier, VT_CL_VERSION_MINOR) &&
           VerifyField<int8_t>(verifier, VT_CL_VERSION_BUILD) &&
           verifier.EndTable();
  }
};

struct CLFindGameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(CLFindGame::VT_PLAYER_UID, player_uid, 0);
  }
  void add_cl_version_major(int8_t cl_version_major) {
    fbb_.AddElement<int8_t>(CLFindGame::VT_CL_VERSION_MAJOR, cl_version_major, 0);
  }
  void add_cl_version_minor(int8_t cl_version_minor) {
    fbb_.AddElement<int8_t>(CLFindGame::VT_CL_VERSION_MINOR, cl_version_minor, 0);
  }
  void add_cl_version_build(int8_t cl_version_build) {
    fbb_.AddElement<int8_t>(CLFindGame::VT_CL_VERSION_BUILD, cl_version_build, 0);
  }
  CLFindGameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLFindGameBuilder &operator=(const CLFindGameBuilder &);
  flatbuffers::Offset<CLFindGame> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<CLFindGame>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLFindGame> CreateCLFindGame(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    int8_t cl_version_major = 0,
    int8_t cl_version_minor = 0,
    int8_t cl_version_build = 0) {
  CLFindGameBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_cl_version_build(cl_version_build);
  builder_.add_cl_version_minor(cl_version_minor);
  builder_.add_cl_version_major(cl_version_major);
  return builder_.Finish();
}

struct SVFindGame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4,
    VT_RESPONSE = 6
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  ConnectionResponse response() const {
    return static_cast<ConnectionResponse>(GetField<int8_t>(VT_RESPONSE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           VerifyField<int8_t>(verifier, VT_RESPONSE) &&
           verifier.EndTable();
  }
};

struct SVFindGameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(SVFindGame::VT_PLAYER_UID, player_uid, 0);
  }
  void add_response(ConnectionResponse response) {
    fbb_.AddElement<int8_t>(SVFindGame::VT_RESPONSE, static_cast<int8_t>(response), 0);
  }
  SVFindGameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVFindGameBuilder &operator=(const SVFindGameBuilder &);
  flatbuffers::Offset<SVFindGame> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<SVFindGame>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVFindGame> CreateSVFindGame(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0,
    ConnectionResponse response = ConnectionResponse_ACCEPTED) {
  SVFindGameBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  builder_.add_response(response);
  return builder_.Finish();
}

struct MSGameFound FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GS_PORT = 4
  };
  uint32_t gs_port() const {
    return GetField<uint32_t>(VT_GS_PORT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_GS_PORT) &&
           verifier.EndTable();
  }
};

struct MSGameFoundBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_gs_port(uint32_t gs_port) {
    fbb_.AddElement<uint32_t>(MSGameFound::VT_GS_PORT, gs_port, 0);
  }
  MSGameFoundBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MSGameFoundBuilder &operator=(const MSGameFoundBuilder &);
  flatbuffers::Offset<MSGameFound> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<MSGameFound>(end);
    return o;
  }
};

inline flatbuffers::Offset<MSGameFound> CreateMSGameFound(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t gs_port = 0) {
  MSGameFoundBuilder builder_(_fbb);
  builder_.add_gs_port(gs_port);
  return builder_.Finish();
}

struct MSEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENT_TYPE = 4,
    VT_EVENT = 6
  };
  MSEvents event_type() const {
    return static_cast<MSEvents>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  const void *event() const {
    return GetPointer<const void *>(VT_EVENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_EVENT) &&
           VerifyMSEvents(verifier, event(), event_type()) &&
           verifier.EndTable();
  }
};

struct MSEventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_event_type(MSEvents event_type) {
    fbb_.AddElement<uint8_t>(MSEvent::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event(flatbuffers::Offset<void> event) {
    fbb_.AddOffset(MSEvent::VT_EVENT, event);
  }
  MSEventBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MSEventBuilder &operator=(const MSEventBuilder &);
  flatbuffers::Offset<MSEvent> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<MSEvent>(end);
    return o;
  }
};

inline flatbuffers::Offset<MSEvent> CreateMSEvent(
    flatbuffers::FlatBufferBuilder &_fbb,
    MSEvents event_type = MSEvents_NONE,
    flatbuffers::Offset<void> event = 0) {
  MSEventBuilder builder_(_fbb);
  builder_.add_event(event);
  builder_.add_event_type(event_type);
  return builder_.Finish();
}

inline bool VerifyMSEvents(flatbuffers::Verifier &verifier, const void *obj, MSEvents type) {
  switch (type) {
    case MSEvents_NONE: {
      return true;
    }
    case MSEvents_CLPing: {
      auto ptr = reinterpret_cast<const CLPing *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MSEvents_MSPing: {
      auto ptr = reinterpret_cast<const MSPing *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MSEvents_CLRegister: {
      auto ptr = reinterpret_cast<const CLRegister *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MSEvents_SVRegister: {
      auto ptr = reinterpret_cast<const SVRegister *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MSEvents_CLLogin: {
      auto ptr = reinterpret_cast<const CLLogin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MSEvents_SVLogin: {
      auto ptr = reinterpret_cast<const SVLogin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MSEvents_CLFindGame: {
      auto ptr = reinterpret_cast<const CLFindGame *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MSEvents_SVFindGame: {
      auto ptr = reinterpret_cast<const SVFindGame *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MSEvents_MSGameFound: {
      auto ptr = reinterpret_cast<const MSGameFound *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMSEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMSEvents(
        verifier,  values->Get(i), types->GetEnum<MSEvents>(i))) {
      return false;
    }
  }
  return true;
}

inline const MSNet::MSEvent *GetMSEvent(const void *buf) {
  return flatbuffers::GetRoot<MSNet::MSEvent>(buf);
}

inline bool VerifyMSEventBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MSNet::MSEvent>(nullptr);
}

inline void FinishMSEventBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MSNet::MSEvent> root) {
  fbb.Finish(root);
}

}  // namespace MSNet

#endif  // FLATBUFFERS_GENERATED_MSNET_MSNET_H_
