// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MSNET_MSNET_H_
#define FLATBUFFERS_GENERATED_MSNET_MSNET_H_

#include "flatbuffers/flatbuffers.h"

namespace MSNet {

struct CLPing;

struct MSPing;

struct CLFindGame;

struct MSGameFound;

struct MSEvent;

enum Type {
  Type_CL_PING = 0,
  Type_MS_PING = 1,
  Type_CL_FIND_GAME = 2,
  Type_MS_GAME_FOUND = 3,
  Type_MIN = Type_CL_PING,
  Type_MAX = Type_MS_GAME_FOUND
};

inline const char **EnumNamesType() {
  static const char *names[] = {
    "CL_PING",
    "MS_PING",
    "CL_FIND_GAME",
    "MS_GAME_FOUND",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesType()[index];
}

enum MSEvents {
  MSEvents_NONE = 0,
  MSEvents_CLPing = 1,
  MSEvents_MSPing = 2,
  MSEvents_CLFindGame = 3,
  MSEvents_MSGameFound = 4,
  MSEvents_MIN = MSEvents_NONE,
  MSEvents_MAX = MSEvents_MSGameFound
};

inline const char **EnumNamesMSEvents() {
  static const char *names[] = {
    "NONE",
    "CLPing",
    "MSPing",
    "CLFindGame",
    "MSGameFound",
    nullptr
  };
  return names;
}

inline const char *EnumNameMSEvents(MSEvents e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMSEvents()[index];
}

template<typename T> struct MSEventsTraits {
  static const MSEvents enum_value = MSEvents_NONE;
};

template<> struct MSEventsTraits<CLPing> {
  static const MSEvents enum_value = MSEvents_CLPing;
};

template<> struct MSEventsTraits<MSPing> {
  static const MSEvents enum_value = MSEvents_MSPing;
};

template<> struct MSEventsTraits<CLFindGame> {
  static const MSEvents enum_value = MSEvents_CLFindGame;
};

template<> struct MSEventsTraits<MSGameFound> {
  static const MSEvents enum_value = MSEvents_MSGameFound;
};

bool VerifyMSEvents(flatbuffers::Verifier &verifier, const void *obj, MSEvents type);
bool VerifyMSEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct CLPing FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CLPingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  CLPingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLPingBuilder &operator=(const CLPingBuilder &);
  flatbuffers::Offset<CLPing> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<CLPing>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLPing> CreateCLPing(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CLPingBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MSPing FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MSPingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  MSPingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MSPingBuilder &operator=(const MSPingBuilder &);
  flatbuffers::Offset<MSPing> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<MSPing>(end);
    return o;
  }
};

inline flatbuffers::Offset<MSPing> CreateMSPing(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MSPingBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CLFindGame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER_UID = 4
  };
  uint32_t player_uid() const {
    return GetField<uint32_t>(VT_PLAYER_UID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PLAYER_UID) &&
           verifier.EndTable();
  }
};

struct CLFindGameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_uid(uint32_t player_uid) {
    fbb_.AddElement<uint32_t>(CLFindGame::VT_PLAYER_UID, player_uid, 0);
  }
  CLFindGameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLFindGameBuilder &operator=(const CLFindGameBuilder &);
  flatbuffers::Offset<CLFindGame> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<CLFindGame>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLFindGame> CreateCLFindGame(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t player_uid = 0) {
  CLFindGameBuilder builder_(_fbb);
  builder_.add_player_uid(player_uid);
  return builder_.Finish();
}

struct MSGameFound FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GS_PORT = 4
  };
  uint32_t gs_port() const {
    return GetField<uint32_t>(VT_GS_PORT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_GS_PORT) &&
           verifier.EndTable();
  }
};

struct MSGameFoundBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_gs_port(uint32_t gs_port) {
    fbb_.AddElement<uint32_t>(MSGameFound::VT_GS_PORT, gs_port, 0);
  }
  MSGameFoundBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MSGameFoundBuilder &operator=(const MSGameFoundBuilder &);
  flatbuffers::Offset<MSGameFound> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<MSGameFound>(end);
    return o;
  }
};

inline flatbuffers::Offset<MSGameFound> CreateMSGameFound(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t gs_port = 0) {
  MSGameFoundBuilder builder_(_fbb);
  builder_.add_gs_port(gs_port);
  return builder_.Finish();
}

struct MSEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EVENT_TYPE = 4,
    VT_EVENT = 6
  };
  MSEvents event_type() const {
    return static_cast<MSEvents>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  const void *event() const {
    return GetPointer<const void *>(VT_EVENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_EVENT) &&
           VerifyMSEvents(verifier, event(), event_type()) &&
           verifier.EndTable();
  }
};

struct MSEventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_event_type(MSEvents event_type) {
    fbb_.AddElement<uint8_t>(MSEvent::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event(flatbuffers::Offset<void> event) {
    fbb_.AddOffset(MSEvent::VT_EVENT, event);
  }
  MSEventBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MSEventBuilder &operator=(const MSEventBuilder &);
  flatbuffers::Offset<MSEvent> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<MSEvent>(end);
    return o;
  }
};

inline flatbuffers::Offset<MSEvent> CreateMSEvent(
    flatbuffers::FlatBufferBuilder &_fbb,
    MSEvents event_type = MSEvents_NONE,
    flatbuffers::Offset<void> event = 0) {
  MSEventBuilder builder_(_fbb);
  builder_.add_event(event);
  builder_.add_event_type(event_type);
  return builder_.Finish();
}

inline bool VerifyMSEvents(flatbuffers::Verifier &verifier, const void *obj, MSEvents type) {
  switch (type) {
    case MSEvents_NONE: {
      return true;
    }
    case MSEvents_CLPing: {
      auto ptr = reinterpret_cast<const CLPing *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MSEvents_MSPing: {
      auto ptr = reinterpret_cast<const MSPing *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MSEvents_CLFindGame: {
      auto ptr = reinterpret_cast<const CLFindGame *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MSEvents_MSGameFound: {
      auto ptr = reinterpret_cast<const MSGameFound *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMSEventsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMSEvents(
        verifier,  values->Get(i), types->GetEnum<MSEvents>(i))) {
      return false;
    }
  }
  return true;
}

inline const MSNet::MSEvent *GetMSEvent(const void *buf) {
  return flatbuffers::GetRoot<MSNet::MSEvent>(buf);
}

inline bool VerifyMSEventBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MSNet::MSEvent>(nullptr);
}

inline void FinishMSEventBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MSNet::MSEvent> root) {
  fbb.Finish(root);
}

}  // namespace MSNet

#endif  // FLATBUFFERS_GENERATED_MSNET_MSNET_H_
